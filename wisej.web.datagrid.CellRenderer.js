///////////////////////////////////////////////////////////////////////////////
//
// (C) 2015 ICE TEA GROUP LLC - ALL RIGHTS RESERVED
//
// 
//
// ALL INFORMATION CONTAINED HEREIN IS, AND REMAINS
// THE PROPERTY OF ICE TEA GROUP LLC AND ITS SUPPLIERS, IF ANY.
// THE INTELLECTUAL PROPERTY AND TECHNICAL CONCEPTS CONTAINED
// HEREIN ARE PROPRIETARY TO ICE TEA GROUP LLC AND ITS SUPPLIERS
// AND MAY BE COVERED BY U.S. AND FOREIGN PATENTS, PATENT IN PROCESS, AND
// ARE PROTECTED BY TRADE SECRET OR COPYRIGHT LAW.
//
// DISSEMINATION OF THIS INFORMATION OR REPRODUCTION OF THIS MATERIAL
// IS STRICTLY FORBIDDEN UNLESS PRIOR WRITTEN PERMISSION IS OBTAINED
// FROM ICE TEA GROUP LLC.
//
///////////////////////////////////////////////////////////////////////////////


/**
 * wisej.web.datagrid.CellRenderer
 *
 * Implements a dynamic cell renderer: it selects the
 * actual renderer according to the individual cell configuration.
 */
qx.Class.define("wisej.web.datagrid.CellRenderer", {

	extend: qx.ui.table.cellrenderer.Abstract,

	/**
	 * Initializes the dynamic cell renderer.
	 *
	 * @param defaultCellRenderer {Object} The default cell renderer .
	 */
	construct: function (defaultCellRenderer) {

		this.base(arguments);

		this.__cellRenderers = {};

		this.__defaultCellRenderer = defaultCellRenderer || new wisej.web.datagrid.cellRenderer.Cell();
	},

	statics: {

		// default css rules to add to all table cell classes generated by the datagrid's style manager.
		DEFAULT_ERROR_CSS: "height:100%;position:absolute;right:0px;top:0px;width:0px;overflow:visible",
		DEFAULT_CSS: "height:100%;position:absolute;top:0px;overflow:hidden;white-space:pre;box-sizing:border-box;background-repeat:no-repeat",
		DEFAULT_CONTENT_CSS: "height:100%;position:relative;box-sizing:border-box;background-repeat:no-repeat;overflow:hidden;white-space:pre;background-origin:inherit",

		// default css rules for the tree-like cells.
		DEFAULT_OPEN_CSS: "float:left;height:100%;background-repeat:no-repeat;position:relative",
		DEFAULT_SPACER_CSS: "float:left;height:100%;background-repeat:no-repeat;position:relative;background-image:none",
	},

	members: {

		// map of shared cell renderers.
		__cellRenderers: null,

		// the default cell renderer instance.
		__defaultCellRenderer: null,

		/**
		 * Returns or changes the default cell renderer.
		 */
		getDefaultCellRenderer: function () {

			return this.__defaultCellRenderer;
		},
		setDefaultCellRenderer: function (value) {

			this.__defaultCellRenderer = value;
		},

		/**
		 * createDataCellHtml indirection.
		 */
		createDataCellHtml: function (cellInfo, htmlArr) {

			// update the cell's width and height before
			// forwarding the call to the specific renderer.
			this.__updateCellBounds(cellInfo);

			return this.__getCellRenderer(cellInfo).createDataCellHtml(cellInfo, htmlArr);
		},

		/**
		 * updateDataCellElement indirection.
		 */
		updateDataCellElement: function (cellInfo, cellElem) {

			return this.__getCellRenderer(cellInfo).updateDataCellElement(cellInfo, cellElem);
		},

		/**
		 * getInsets indirection.
		 */
		getInsets: function (cellInfo) {

			return this.__getCellRenderer(cellInfo).getInsets(cellInfo);
		},

		/**
		 * Returns the rows's border size.
		 *
		 * @param rowInfo {Map} The information about the row.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {Map} Contains the keys <code>top</code>, <code>right</code>,
		 *   <code>bottom</code> and <code>left</code>. All values are integers.
		 */
		getRowInsets: function (rowInfo) {

			var rowRenderer = rowInfo.table.getDataRowRenderer();
			return rowRenderer.getInsets(rowInfo);
		},

		/**
		 * getCellSize indirection.
		 */
		getCellSize: function (cellInfo) {

			// update the cell's width and height before
			// forwarding the call to the specific renderer.
			this.__updateCellBounds(cellInfo);

			return this.__getCellRenderer(cellInfo).getCellSize(cellInfo);
		},

		/**
		 * Returns (creates if it doesn't exist yet) the cell renderer
		 * for the specific cell according to the cell's information.
		 */
		__getCellRenderer: function (cellInfo) {

			var className = null;

			// determine the cell renderer class.
			var rowData = cellInfo.rowData;
			var columnIndex = cellInfo.col;
			if (rowData) {

				// first see if there is a cached renderer.
				rowData.cachedCellRenderers = rowData.cachedCellRenderers || {};
				var cachedRenderer = rowData.cachedCellRenderers[columnIndex];
				if (cachedRenderer)
					return cachedRenderer;

				var colStyle = cellInfo.columnModel.getColumnStyle(columnIndex);
				var cellStyle = rowData.styles ? rowData.styles[columnIndex] : null;

				// see if the cell or the column specified a renderer class name.
				className = cellStyle != null ? cellStyle.renderer : null;
				className = className || (colStyle != null ? colStyle.renderer : null);

				if (className) {
					if (className.indexOf(".") == -1)
						className = "wisej.web.datagrid.cellRenderer." + className;
				}
			}

			// use the default renderer?
			if (!className)
				return this.__defaultCellRenderer;

			// retrieve or create the cell renderer.
			var renderer = this.__cellRenderers[className];
			if (!renderer) {
				var clazz = qx.Class.getByName(className);
				this.__cellRenderers[className] = renderer = (clazz ? new clazz : this.__defaultCellRenderer);
			}

			// cache it for quick reuse.
			if (rowData)
				rowData.cachedCellRenderers[columnIndex] = renderer;

			// done, return the actual cell renderer.
			return renderer;
		},

		/**
		 * Calculates the width and height of the cell.
		 *
		 * When its colSpan and rowSpan style properties are > 1
		 * we return {width:#,height:#).
		 *
		 * Otherwise we return {width:#, height:null} to skip setting the
		 * height style on every cell.
		 */
		__updateCellBounds: function (cellInfo) {

			// we re-calculate the cell only when the rowSpan or colSpan > 1.
			var col = cellInfo.col;
			var row = cellInfo.row;
			var rowData = cellInfo.rowData;
			if (rowData && rowData.styles) {

				var style = rowData.styles[col];
				if (style) {

					var colSpan = style.colSpan || 1;
					var rowSpan = style.rowSpan || 1;

					if (colSpan > 1 || rowSpan > 1) {

						var insets = this.getRowInsets(cellInfo);
						var columnModel = cellInfo.columnModel;
						var dataModel = cellInfo.table.getTableModel();
						var paneModel = cellInfo.scroller.getTablePaneModel();

						var cellHeight = 0;
						var rowCount = dataModel.getRowCount();
						for (var rowIndex = row, maxIndex = Math.min(rowCount, rowIndex + rowSpan) ;
							rowIndex < maxIndex; rowIndex++) {
							cellHeight += dataModel.getRowHeight(rowIndex);
						}
						cellHeight = cellHeight - insets.top - insets.bottom;

						var cellWidth = 0;
						var colCount = paneModel.getColumnCount();
						for (var colPos = cellInfo.xPos, maxIndex = Math.min(colCount, colPos + colSpan);
							colPos < maxIndex; colPos++) {
							cellWidth += columnModel.getColumnWidth(paneModel.getColumnAtX(colPos));
						}
						cellWidth = cellWidth - insets.left - insets.right;

						cellInfo.colSpan = colSpan;
						cellInfo.rowSpan = rowSpan;
						cellInfo.styleWidth = cellWidth;
						cellInfo.styleHeight = cellHeight;

						return;
					}
				}
			}

			cellInfo.styleHeight = null;
		},

		// overridden to disable the creation of the qooxdoo cell class.
		// we create grid classes in wisej.web.DataGrid reading the decorators from the current theme.
		_createStyleSheet: function () {
		},

		_onChangeTheme: function () {
		},

	},

	destruct: function () {

		this._disposeMap("__cellRenderers");
		this._disposeObjects("__defaultCellRenderer");
	}
});


/**
 * wisej.web.datagrid.cellRenderer.Cell
 *
 * Extends the QX cell renderer to support the theme system and
 * the new row height and cell styles.
 *
 * This is also the base class for all wisej cell renderers.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.Cell", {

	extend: qx.ui.table.cellrenderer.Abstract,

	construct: function (appearance) {

		this.base(arguments);

		if (appearance)
			this.setAppearance(appearance);

		this._colorMgr = qx.theme.manager.Color.getInstance();
		this._styleMgr = wisej.web.datagrid.StyleManager.getInstance();

		// create the css classes needed to render standard cells.
		this._registerCssClasses();
	},

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-cell" },
	},

	members: {

		// style manager singleton reference: a bit faster to keep it here.
		_styleMgr: null,

		// color manager singleton reference: a bit faster to keep it here.
		_colorMgr: null,

		// class name for the error element.
		_errorClassName: null,

		// class name for the content element.
		_contentClassName: null,
		_contentMiddelClassName: null,
		_contentBottomClassName: null,

		/**
		 * Creates the HTML for a data cell.
		 */
		createDataCellHtml: function (cellInfo, htmlArr) {

			htmlArr.push(
				"<div role='cell' ",
				"col='", cellInfo.col, "' ",
				"row='", cellInfo.row, "' ",
				"class='",
				this._getCellClass(cellInfo), "' ",
				this._getTooltipAttribute(cellInfo),
				this._getCellWidgetAttribute(cellInfo),
				"style='left:", cellInfo.styleLeft, "px;",
					this._getCellSizeStyle(cellInfo.styleWidth, cellInfo.styleHeight),
					this._getCellStyle(cellInfo),
				"'>",

				this._getContentHtml(cellInfo),
				this._getErrorHtml(cellInfo),

				"</div>"
			);

		},

		/**
		 * Get a string of the cell element's HTML classes.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} cellInfo of the cell
		 * @return {String} The table cell HTML classes as string.
		 */
		_getCellClass: function (cellInfo) {

			var styleMgr = this._styleMgr;
			var appearance = this.getAppearance();
			var state = this._getCellState(cellInfo);

			return "qx-cell " + styleMgr.getCssClass(appearance, state, wisej.web.datagrid.CellRenderer.DEFAULT_CSS);
		},

		// builds the state map for the cell.
		_getCellState: function (cellInfo) {

			var state = {};

			// focused?
			if (cellInfo.focusedRow && cellInfo.focusedCol) {

				state.focused = true;
			}

			// selected?
			if (cellInfo.selected) {

				state.selected = true;
			}
			else {

				// use the selected flag from the owning column.
				if (cellInfo.columnModel.getColumnSelected(cellInfo.col))
					state.selected = true;
			}

			// even or odd?
			if (cellInfo.row % 2 == 0)
				state.even = true;
			else
				state.odd = true;

			// right to left?
			if (cellInfo.rightToLeft)
				state.rightToLeft = true;

			// cell border.
			state[cellInfo.table._gridLinesStateName] = true;

			// add cell specific states.
			if (cellInfo.rowData && cellInfo.rowData.styles) {
				var cellStyle = cellInfo.rowData.styles[cellInfo.col];
				if (cellStyle && cellStyle.state)
					state[cellStyle.state] = true;
			}

			// expanded or collapsed?
			var data = cellInfo.rowData;
			if (cellInfo.xPos == 0
				&& !cellInfo.scroller.isFrozenPane()
				&& !cellInfo.scroller.isRowHeaderPane()
				&& data && data.expanded !== undefined) {

				if (data.expanded === true) {
					state.expanded = true;
				}
				else if (data.expanded === false) {
					state.collapsed = true;
				}
			}

			return state;
		},

		/**
		 * Returns the HTML that should be used inside the main div of this cell.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {String} the inner HTML of the cell.
		 */
		_getContentHtml: function (cellInfo) {

			var html = "";

			// if the cell style contains verticalAlign different from top, we wrap
			// the cell content into a div to set the vertical alignment.
			// NOTE: "middle" is the default.

			var htmlArr = [];
			var table = cellInfo.table;
			var data = cellInfo.rowData;
			var cellValue = this._getCellValue(cellInfo);
			var cellStyle = this._resolveCellStyle(cellInfo);
			var vAlign = cellStyle ? cellStyle.verticalAlign : null;

			// if this is a tree-cell, add the open/close icon.
			if (cellInfo.xPos === 0
				&& !cellInfo.scroller.isFrozenPane()
				&& !cellInfo.scroller.isRowHeaderPane()
				&& cellInfo.col > table._rowHeaderColIndex
				&& data && (data.expanded !== undefined || data.level !== undefined)) {

				// add the spacer.
				if (data.level > 0) {
					var paddingLeft = data.level * cellInfo.table.getIndent();
					htmlArr.push(
						"<div role='spacer' class='", this._contentSpacerClassName,
						"' style='padding-left:", paddingLeft, "px");

					htmlArr.push("'></div>");
				}

				if (data.expanded === true)
					htmlArr.push("<div role='close' class='", this._contentExpandedClassName);
				else if (data.expanded === false)
					htmlArr.push("<div role='open' class='", this._contentCollapsedClassName);
				else
					htmlArr.push("<div role='spacer' class='", this._contentButtonSpacerClassName);

				htmlArr.push("'></div>");
			}

			htmlArr.push(
				"<div role='content' class='",
				this._contentClassName,
				"'>"
			);

			// middle is the default.
			vAlign = vAlign || "middle";
			if (vAlign === "middle" || vAlign === "bottom") {

				if (cellValue) {
					htmlArr.push(
						"<div class='",
						vAlign === "bottom" ? this._contentBottomClassName : this._contentMiddleClassName,
						"'>",
						cellValue,
						"</div>");
				}
			}
			else {

				if (cellValue) {
					htmlArr.push(
						cellValue);
				}
			}
			htmlArr.push("</div>");
			html = htmlArr.join("");

			return html;
		},

		/**
		 * Get the cell size taking the box model into account
		 *
		 * @param width {Integer} The cell's (border-box) width in pixel
		 * @param height {Integer} The cell's (border-box) height in pixel
		 * @param insetX {Integer} The cell's horizontal insets, i.e. the sum of
		 *    horizontal paddings and borders
		 * @param insetY {Integer} The cell's vertical insets, i.e. the sum of
		 *    vertical paddings and borders
		 * @return {String} The CSS style string for the cell size
		 */
		_getCellSizeStyle: function (width, height, insetX, insetY) {

			var style = "";

			if (width != null) {

				style += "width:" + width + "px;";

				if (height != null)
					style += ";height:" + height + "px;";
			}

			return style;

		},

		/**
		 * Returns the HTML that should be used next the main div of this cell to display the error information.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {String} the inner HTML of the cell.
		 */
		_getErrorHtml: function (cellInfo) {

			if (cellInfo.rowData) {
				var errors = cellInfo.rowData.errors;
				var errorText = errors ? errors[cellInfo.col] : null;
				if (errorText) {

					var errorHtml =
						[
							"<div class='",
							this._errorClassName,
							"' title='",
							errorText,
							"'></div>"
						].join("");

					return errorHtml;
				}
			}

			return "";
		},

		/**
		 * Returns the attribute to add to the cell's element definition to show the
		 * tooltip using the simple "title" attribute.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {String} the title attribute or an empty string.
		 */
		_getTooltipAttribute: function (cellInfo) {

			if (cellInfo.rowData) {
				var tooltips = cellInfo.rowData.tooltips;
				var tooltipText = tooltips ? tooltips[cellInfo.col] : null;
				if (tooltipText) {
					return "title='" + tooltipText + "' ";
				}
			}

			return "";
		},

		/**
		 * Returns the attribute to add to the cell's element definition to bind a
		 * child widget to the cell.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {String} the title attribute or an empty string.
		 */
		_getCellWidgetAttribute: function (cellInfo) {

			if (cellInfo.rowData && cellInfo.rowData.styles) {

				var styles = cellInfo.rowData.styles[cellInfo.col];
				if (styles && styles.widgetId) {
					return "qx-widget-id='" + styles.widgetId + "' " +
							"qx-widget-dock='" + styles.widgetDock + "' ";
				}
			}

			return "";
		},

		/**
		 * Returns the CSS styles that should be applied to the main div of this
		 * cell.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {var} the CSS styles of the main div.
		 */
		_getCellStyle: function (cellInfo) {

			var cellStyle = this._resolveCellStyle(cellInfo);
			var cellCss = (cellStyle ? cellStyle.css : "") || "";

			// if the cell spans over the next cells, add the reverse z-index.
			if (cellCss && !qx.lang.String.endsWith(cellCss, ";"))
				cellCss += ";";

			cellCss += "z-index:" + ((10000 - cellInfo.xPos) || 0) + "";

			return cellCss;
		},

		/**
		 * Returns the value to render inside the cell.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 */
		_getCellValue: function (cellInfo) {

			return cellInfo.value;
		},

		/**
		 * Resolves the theme values (colors and images) and caches the realized css string ready to use.
		 *
		 * Merges the cell style as follows:
		 * 
		 *		- grid default cell style + column style + row Style + cell style
		 *		- the values are merged, therefore the last style to be applied takes precedence.
		 */
		_resolveCellStyle: function (cellInfo) {

			var table = cellInfo.table;
			var rowData = cellInfo.rowData;
			if (rowData) {

				var columnIndex = cellInfo.col;

				// reuse the cached and realized style?
				rowData.cachedStyles = rowData.cachedStyles || {};
				var cachedStyle = rowData.cachedStyles[columnIndex];

				// resolve the theme values and cache the cell style.
				if (cachedStyle == null) {

					cachedStyle = {};

					var rowStyle = rowData.style;
					var defaultStyle = table.getDefaultCellStyle();
					var colStyle = cellInfo.columnModel.getColumnStyle(columnIndex);
					var cellStyle = rowData.styles ? rowData.styles[columnIndex] : null;

					// apply the style in this order: default + colStyle + rowStyle + cellStyle.
					if (defaultStyle && cellInfo.col > table._rowHeaderColIndex)
						qx.lang.Object.mergeWith(cachedStyle, defaultStyle, true);
					if (colStyle)
						qx.lang.Object.mergeWith(cachedStyle, colStyle, true);
					if (rowStyle && cellInfo.col > table._rowHeaderColIndex)
						qx.lang.Object.mergeWith(cachedStyle, rowStyle, true);
					if (cellStyle)
						qx.lang.Object.mergeWith(cachedStyle, cellStyle, true);

					if (!qx.lang.Object.isEmpty(cachedStyle)) {

						// cache the css style for next use.
						rowData.cachedStyles[columnIndex] = this._translateStyle(cellInfo, cachedStyle);

						// resolve the background image.
						if (cachedStyle.backgroundImage) {

							// if it's a user-paint postback image, update the url and don't preload.
							if (cachedStyle.backgroundImage.indexOf("postback.wx") > -1) {

								this.__updateUserPaintPostback(cellInfo, cachedStyle);
								cachedStyle.backgroundImage = "url(\"" + cachedStyle.backgroundImage + "\")";

							}
							else {

								var me = this;
								var cell = qx.lang.Object.clone(cellInfo);
								cachedStyle.backgroundImage = this._resolveImage(cachedStyle.backgroundImage, cachedStyle.color, function (url) {

									cachedStyle.css = undefined;
									cachedStyle.backgroundImage = url;
									cachedStyle.backgroundPosition = cachedStyle.backgroundPosition || "center left";
									cachedStyle.css = qx.bom.element.Style.compile(cachedStyle);
									// update the cell element.
									me.updateDataCellHtml(cell);

								});
							}

							cachedStyle.backgroundPosition = cachedStyle.backgroundPosition || "center left";
						}

						// compile the style rules into a css string.
						cachedStyle.css = undefined;
						cachedStyle.css = qx.bom.element.Style.compile(cachedStyle);
					}
					else {
						rowData.cachedStyles[columnIndex] = null;
					}
				}
				else {

					// if it's a user-paint postback image, update the url to reflect the new cell size.
					if (cachedStyle.backgroundImage && cachedStyle.backgroundImage.indexOf("postback.wx") > -1) {

						this.__updateUserPaintPostback(cellInfo, cachedStyle);
					}
				}

				return cachedStyle;
			}
		},

		// Updates the size (w and h parameters) in the postback url
		// used for user-paint cells.
		__updateUserPaintPostback: function (cellInfo, cellStyle) {

			var width = cellInfo.styleWidth;
			var height = cellInfo.styleHeight;
			if (height == null) {
				var rowRenderer = cellInfo.table.getDataRowRenderer();
				var insets = rowRenderer.getInsets(cellInfo);
				var dataModel = cellInfo.table.getTableModel();

				height = dataModel.getRowHeight(cellInfo.row) - insets.top - insets.bottom;
			}

			cellStyle.backgroundImage =
				cellStyle.backgroundImage.replace(/\&w=\d*/, "&w=" + width).replace(/\&h=\d*/, "&h=" + height);

			if (cellStyle.css)
				cellStyle.css = cellStyle.css.replace(/\&w=\d*/, "&w=" + width).replace(/\&h=\d*/, "&h=" + height);
		},

		/**
		 * Resolves theme images, loads images, adapts the svg icon color and updates the cell's style
		 * when the image is loaded and cached.
		 *
		 * @param image {String} Image name or url.
		 * @param color {String} text color to apply to svg images.
		 * @param callback {Function} Callback invoked when the image is loaded; it's not called if the image is loaded synchronously or already loaded.
		 *
		 * @return {String} the image url or undefined if the image is being loaded.
		 */
		_resolveImage: function (image, color, callback) {

			if (!image)
				return null;

			var imageUtils = qx.ui.basic.Image;
			var imageLoader = qx.io.ImageLoader;
			var imageColor = imageUtils.resolveImage(image, color);

			imageLoader.load(imageColor.source);

			// if the image is preloaded already, complete the rendering of the image now.
			if (imageLoader.isLoaded(imageColor.source)) {

				// change the svg image color, if specified either in the image source url or as the cell's text color.
				if (imageColor.color) {
					var svg = imageLoader.getSvg(imageColor.source);
					if (svg)
						imageColor.source = imageUtils.getSvgDataUri(imageUtils.setSvgColor(svg, imageColor.color));
				}
				return "url(\"" + imageColor.source + "\")";
			}
			else if (imageLoader.isLoading(imageColor.source)) {

				var me = this;

				// otherwise we have to wait for the image to preload and then update the cell.
				imageLoader.load(imageColor.source, function (url, entry) {

					// change the svg image color, if specified either in the image source url or as the cell's text color.
					if (imageColor.color) {
						var svg = imageLoader.getSvg(imageColor.source);
						if (svg)
							imageColor.source = imageUtils.getSvgDataUri(imageUtils.setSvgColor(svg, imageColor.color));
					}

					// callback with the resolved image.
					callback.call(me, "url(\"" + imageColor.source + "\")");
				});
			}
		},

		// translates style properties to valid css style rules.
		_translateStyle: function (cellInfo, style) {

			// remove the renderer name, it's not part of the css rules.
			delete style.renderer;

			// remove the widget data, it's not part of the css rules.
			delete style.widgetId;
			delete style.widgetDock;

			// remove the colSpan and rowSpan, they are not part of the css rules.
			delete style.colSpan;
			delete style.rowSpan;

			// translate and resolve the style values coming from the server.
			if (!style.css) {

				if (style.color)
					style.color = this._colorMgr.resolve(style.color);

				if (style.backgroundColor)
					style.backgroundColor = this._colorMgr.resolve(style.backgroundColor);

				if (style.font)
					this._translateFont(style, style.font);

				if (style.padding)
					this._translatePadding(style, style.padding);

				if (style.whiteSpace)
					this._translateWhiteSpace(style, style.whiteSpace);

				if (style.textAlign)
					this._translateTextAlign(style, style.textAlign, cellInfo.rightToLeft);

				if (style.backgroundLayout)
					this._translateBackgroundLayout(style, style.backgroundLayout, cellInfo.rightToLeft);

				if (style.backgroundPosition)
					this._translateBackgroundPosition(style, style.backgroundPosition, cellInfo.rightToLeft);
			}

			return style;
		},

		_translateFont: function (style, value) {

			delete style.font;

			var font = qx.theme.manager.Font.getInstance().resolve(value);
			if (font) {

				var fontStyle = font.getStyles();
				for (var name in fontStyle)
					style[name] = fontStyle[name];
			}

		},

		_translatePadding: function (style, value) {

			if (value instanceof Array) {
				style.padding = value.join("px ") + "px";
			}
			else {
				style.padding = value + "px";
			}
		},

		_translateBackgroundLayout: function (style, value, rightToLeft) {

			delete style.backgroundLayout;

			switch (value) {

				case "none":
					if (rightToLeft)
						style.backgroundPosition = "top right";
					else
						style.backgroundPosition = "top left";
					break;

				case "tile":
					style.backgroundRepeat = "repeat";
					break;

				case "center":
					style.backgroundPosition = "center center";
					break;

				case "stretch":
					style.backgroundSize = "100% 100%";
					break;

				case "zoom":
					style.backgroundSize = "cover";
					break;

				case "bestFit":
					style.backgroundSize = "contain";
					break;

				case "originalSize":
					style.backgroundSize = "auto";
					break;

			}
		},

		_translateBackgroundPosition: function (style, value, rightToLeft) {

			var left = rightToLeft ? "right": "left";
			var right = rightToLeft ? "left" : "right";

			switch (value) {

				case "topRight":
					style.backgroundPosition = "top " + right;
					break;
				case "middleRight":
					style.backgroundPosition = "center " + right;
					break;
				case "bottomRight":
					style.backgroundPosition = "bottom " + right;
					break;
				case "topLeft":
					style.backgroundPosition = "top " + left;
					break;
				case "topCenter":
					style.backgroundPosition = "top center";
					break;
				case "middleLeft":
					style.backgroundPosition = "center " + left;
					break;
				case "middleCenter":
					style.backgroundPosition = "center center";
					break;
				case "bottomLeft":
					style.backgroundPosition = "bottom " + left;
					break;
				case "bottomCenter":
					style.backgroundPosition = "bottom center";
					break;
			}
		},

		_translateWhiteSpace: function (style, value) {

			switch (value) {
				case "true":
					style.whiteSpace = "pre-wrap";
					style.wordWrap = "inherit";
					break;

				case "false":
					style.whiteSpace = "pre";
					style.wordWrap = "normal";
					break;
			}
		},

		_translateTextAlign: function (style, value, rightToLeft) {

			var left = rightToLeft ? "right" : "left";
			var right = rightToLeft ? "left" : "right";

			switch (value) {

				case "topRight":
					style.verticalAlign = "top";
					style.textAlign = right;
					break;

				case "middleRight":
					style.verticalAlign = "middle";
					style.textAlign = right;
					break;

				case "bottomRight":
					style.verticalAlign = "bottom";
					style.textAlign = right;
					break;

				case "topLeft":
					style.verticalAlign = "top";
					style.textAlign = left;
					break;

				case "middleLeft":
					style.verticalAlign = "middle";
					style.textAlign = left;
					break;

				case "bottomLeft":
					style.verticalAlign = "bottom";
					style.textAlign = left;
					break;

				case "topCenter":
					style.verticalAlign = "top";
					style.textAlign = "center";
					break;

				case "middleCenter":
					style.verticalAlign = "middle";
					style.textAlign = "center";
					break;

				case "bottomCenter":
					style.verticalAlign = "bottom";
					style.textAlign = "center";
					break;
			}

		},


		// updates the style attribute directly on the cell element. 
		updateDataCellHtml: function (cellInfo) {

			// retrieve the cell element.
			var pane = cellInfo.scroller.getTablePane();
			var dom = pane.getContentElement().getDomElement();
			if (!dom || !dom.firstChild)
				return;

			var cellElem = null;

			var rowNodes = dom.firstChild.childNodes;
			var colIndex = pane.getPaneScroller().getTablePaneModel().getX(cellInfo.col)
			var rowIndex = cellInfo.row - pane.getFirstVisibleRow();
			if (rowIndex >= 0 && rowIndex < rowNodes.length) {
				var rowElem = rowNodes[rowIndex];
				if (rowElem && colIndex >= 0 && colIndex < rowElem.childNodes.length)
					cellElem = rowElem.childNodes[colIndex];
			}

			if (!cellElem)
				return;

			// replace the cell element.
			var htmlArr = [];
			this.createDataCellHtml(cellInfo, htmlArr);
			cellElem.outerHTML = htmlArr.join("");

			// invalidate the cached row, or at the next update we'll get the cached html.
			pane.invalidateCachedRow(cellInfo.row);

			// update the hosted widget, if any.
			pane.updateHostedWidget(rowElem.childNodes[colIndex]);
		},

		// updates the css class directly on the cell element.
		updateDataCellElement: function (cellInfo, cellElem) {

			cellInfo.value = cellInfo.rowData && cellInfo.rowData.data
				? cellInfo.rowData.data[cellInfo.col]
				: undefined;

			// update the cell element class.
			var className = this._getCellClass(cellInfo);
			if (className && cellElem.className != className)
				cellElem.className = className;
		},

		// overridden to disable the creation of the qooxdoo cell class.
		// we create grid classes in wisej.web.DataGrid reading the decorators from the current theme.
		_createStyleSheet: function () {
		},

		// overridden to disable the creation of the qooxdoo cell class.
		// we create grid classes in wisej.web.DataGrid reading the decorators from the current theme.
		_onChangeTheme: function () {
		},

		/**
		 * Returns the cell's border size.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {Map} Contains the keys <code>top</code>, <code>right</code>,
		 *   <code>bottom</code> and <code>left</code>. All values are integers.
		 */
		getInsets: function (cellInfo) {

			var insets = this._styleMgr.getBorder(
				this.getAppearance(),
				{ focused: cellInfo.focusedRow || cellInfo.focusedCol, selected: cellInfo.selected });

			return insets;
		},

		/**
		 * Returns the calculated size of the content. Doesn't take in consideration
		 * colSpan and rowSpan.
		 */
		getCellSize: function (cellInfo) {

			var htmlArr = [];
			htmlArr.push(
				"<div role='cell' ",
				"col='", cellInfo.col, "' ",
				"row='", cellInfo.row, "' ",
				"class='",
				this._getCellClass(cellInfo), "' ",
				"style='",
					this._getCellStyle(cellInfo),
				"'>",
				this._getContentHtml(cellInfo),
				"</div>"
			);
			var html = htmlArr.join("");

			var fontStyle = cellInfo.table._getFontStyle();
			var size = wisej.utils.Widget.measure(html, null, fontStyle);
			return size;
		},

		/**
		 * Creates the additional css classes needed for this renderer.
		 */
		_registerCssClasses: function () {

			var styleMgr = this._styleMgr;
			var appearance = this.getAppearance();

			// error element.
			this._errorClassName = styleMgr.getCssClass(appearance + "/error", {}, wisej.web.datagrid.CellRenderer.DEFAULT_ERROR_CSS);

			// register the pseudo classes to support hovering since cannot handle it in the code because cells are not widgets.
			styleMgr.createCssPseudoClass(this._errorClassName + ":hover", appearance + "/error", { hovered: true }, "");

			// content element.
			this._contentClassName = styleMgr.getCssClass(appearance + "/content", {}, wisej.web.datagrid.CellRenderer.DEFAULT_CONTENT_CSS);
			this._contentMiddleClassName = styleMgr.getCssClass(appearance + "/content/middle", {}, wisej.web.datagrid.CellRenderer.DEFAULT_CONTENT_CSS + ";height:auto;top:50%;transform:translateY(-46%);-webkit-transform:translateY(-46%);max-height:100%;white-space:inherit;word-wrap:inherit;text-overflow:inherit");
			this._contentBottomClassName = styleMgr.getCssClass(appearance + "/content/bottom", {}, wisej.web.datagrid.CellRenderer.DEFAULT_CONTENT_CSS + ";height:auto;top:100%;transform:translateY(-100%);-webkit-transform:translateY(-100%);max-height:100%;white-space:inherit;word-wrap:inherit;text-overflow:inherit");
			this._contentSpacerClassName = styleMgr.getCssClass(appearance + "/spacer", {}, wisej.web.datagrid.CellRenderer.DEFAULT_SPACER_CSS);
			this._contentButtonSpacerClassName = styleMgr.getCssClass(appearance + "/open", {}, wisej.web.datagrid.CellRenderer.DEFAULT_SPACER_CSS);
			this._contentExpandedClassName = styleMgr.getCssClass(appearance + "/open", { expanded: true }, wisej.web.datagrid.CellRenderer.DEFAULT_OPEN_CSS);
			this._contentCollapsedClassName = styleMgr.getCssClass(appearance + "/open", { collapsed: true }, wisej.web.datagrid.CellRenderer.DEFAULT_OPEN_CSS);
		},

	}
});


/**
 * wisej.web.datagrid.cellRenderer.CheckBoxCell
 *
 * Specialized cell renderer for check-box cells.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.CheckBoxCell", {

	extend: wisej.web.datagrid.cellRenderer.Cell,

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-checkbox-cell", refine: true },
	},

	statics: {

		DEFAULT_CHECKBOX_CSS: "display:inline-block;background-repeat:no-repeat",

	},
	members: {

		// checkbox element classes.
		_contentCheckBoxClassName: null,
		_contentCheckBoxCheckedClassName: null,
		_contentCheckBoxUndeterminedClassName: null,

		/**
		 * Returns the value to render inside the cell.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 */
		_getCellValue: function (cellInfo) {

			// determine the checkbox state.
			var checkboxClassName = this._contentCheckBoxUndeterminedClassName;
			if (cellInfo.value === true)
				checkboxClassName = this._contentCheckBoxCheckedClassName;
			else if (cellInfo.value === false)
				checkboxClassName = this._contentCheckBoxClassName;

			var htmlArr = [
				"<div role='checkbox' class='",
				checkboxClassName,
				"'></div>"
			];

			return htmlArr.join("");
		},

		/**
		 * Creates the additional css classes needed for this renderer.
		 */
		_registerCssClasses: function () {

			this.base(arguments);

			var styleMgr = this._styleMgr;
			var appearance = this.getAppearance() + "/checkbox";

			// checkbox element.
			this._contentCheckBoxClassName = styleMgr.getCssClass(appearance, {}, wisej.web.datagrid.cellRenderer.CheckBoxCell.DEFAULT_CHECKBOX_CSS);
			this._contentCheckBoxCheckedClassName = styleMgr.getCssClass(appearance, { checked: true }, wisej.web.datagrid.cellRenderer.CheckBoxCell.DEFAULT_CHECKBOX_CSS);
			this._contentCheckBoxUndeterminedClassName = styleMgr.getCssClass(appearance, { undetermined: true }, wisej.web.datagrid.cellRenderer.CheckBoxCell.DEFAULT_CHECKBOX_CSS);
		},

	},
});


/**
 * wisej.web.datagrid.cellRenderer.ImageCell
 *
 * Specialized cell renderer for image cells.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.ImageCell", {

	extend: wisej.web.datagrid.cellRenderer.Cell,

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-image-cell", refine: true },
	},

	members: {

		/**
		 * Returns the HTML that should be used inside the main div of this cell.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {String} the inner HTML of the cell.
		 */
		_getContentHtml: function (cellInfo) {

			var cellStyle = this._resolveCellStyle(cellInfo);
			var value = this._getCellValue(cellInfo);

			var htmlArr =
				[
					"<div role='content' class='",
					this._contentClassName,
					"'>"
				];

			if (value && value.source) {

				// resolve the cell image.
				var me = this;
				var cell = qx.lang.Object.clone(cellInfo);
				var color = cellStyle ? cellStyle.color : null;
				var imageUrl = this._resolveImage(value.source, color, function (url) {

					me.updateDataCellHtml(cell);

				});

				if (imageUrl) {

					var imageStyle = {
						backgroundImage: imageUrl,
						backgroundSize: "inherit",
						backgroundRepeat: "no-repeat",
						backgroundPosition: "center center"
					};

					// inherit shared value from column and translate the
					// layout and alignment to css styles.
					var colData = cellInfo.columnModel.getColumnData(cellInfo.col) || {};
					this._translateBackgroundLayout(imageStyle, value.layout || colData.layout, cellInfo.rightToLeft);
					this._translateBackgroundPosition(imageStyle, value.alignment || colData.alignment, cellInfo.rightToLeft);
					var imageCss = qx.bom.element.Style.compile(imageStyle);

					htmlArr.push(
						"<div role='image' style='height:100%;", imageCss, "'></div>"
					);
				}
			}

			htmlArr.push("</div>");

			return htmlArr.join("");
		},

	},
});


/**
 * wisej.web.datagrid.cellRenderer.DateFieldCell
 *
 * Specialized cell renderer for date-field cells.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.DateFieldCell", {

	extend: wisej.web.datagrid.cellRenderer.Cell,

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-datefield-cell", refine: true },
	},
});


/**
 * wisej.web.datagrid.cellRenderer.ComboBoxCell
 *
 * Specialized cell renderer for combobox cells.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.ComboBoxCell", {

	extend: wisej.web.datagrid.cellRenderer.Cell,

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-combobox-cell", refine: true },
	},
});


/**
 * wisej.web.datagrid.cellRenderer.ButtonCell
 *
 * Specialized cell renderer for button cells.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.ButtonCell", {

	extend: wisej.web.datagrid.cellRenderer.Cell,

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-button-cell", refine: true },
	},

	members: {

		// button cell's class name.
		_buttonClassName: null,

		/**
		 * Returns the HTML that should be used inside the main div of this cell.
		 *
		 * This method may be overridden by sub classes.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 * @return {String} the inner HTML of the cell.
		 */
		_getContentHtml: function (cellInfo) {

			var htmlArr = [
				"<div role='button' class='", this._buttonClassName, "'>",
				this.base(arguments, cellInfo),
				"</div>"
			];

			return htmlArr.join("");
		},

		/**
		 * Creates the additional css classes needed for this renderer.
		 */
		_registerCssClasses: function () {

			this.base(arguments);

			var styleMgr = this._styleMgr;
			var appearance = this.getAppearance() + "/button";

			// base class.
			this._buttonClassName = styleMgr.getCssClass(appearance, {}, "height:100%;box-sizing:border-box;background-repeat:no-repeat;background-origin:content-box");

			// register the pseudo classes to support hovering and pressed states since
			// we cannot handle it in the code because cells are not widgets.
			styleMgr.createCssPseudoClass(this._buttonClassName + ":hover", appearance, { hovered: true }, "");
			styleMgr.createCssPseudoClass(this._buttonClassName + ":active", appearance, { pressed: true }, "");
		},
	}
});


/**
 * wisej.web.datagrid.cellRenderer.LinkCell
 *
 * Specialized cell renderer for link cells.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.LinkCell", {

	extend: wisej.web.datagrid.cellRenderer.Cell,

	construct: function (appearance) {

		this.base(arguments, appearance);

		// register the button-cell css classes.
		this._linkClassName = this.__registerLinkClass();

	},

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-link-cell", refine: true },
	},

	members: {

		_linkClassName: null,

		/**
		 * Creates the additional css classes needed for this renderer.
		 */
		__registerLinkClass: function () {

			var styleMgr = this._styleMgr;
			var appearance = this.getAppearance() + "/link";

			// base class.
			var linkClass = styleMgr.getCssClass(appearance, {}, "");

			// register the pseudo classes to support hovering since
			// we cannot handle it in the code because cells are not widgets.
			styleMgr.createCssPseudoClass(linkClass + ":hover", appearance, { hovered: true }, ""); // systemDefault = theme setting.
			styleMgr.createCssPseudoClass(linkClass + "-neverUnderline", appearance, {}, "text-decoration:none");
			styleMgr.createCssPseudoClass(linkClass + "-alwaysUnderline", appearance, {}, "text-decoration:underline;cursor:pointer");
			styleMgr.createCssPseudoClass(linkClass + "-hoverUnderline", appearance, {}, "text-decoration:none");
			styleMgr.createCssPseudoClass(linkClass + "-hoverUnderline:hover", appearance, {}, "text-decoration:underline;cursor:pointer");

			return linkClass;

		},

		/**
		 * Returns the value to render inside the cell.
		 *
		 * @param cellInfo {Map} The information about the cell.
		 *          See {@link qx.ui.table.cellrenderer.Abstract#createDataCellHtml}.
		 */
		_getCellValue: function (cellInfo) {

			var value = cellInfo.value;
			if (value && value.text) {

				// inherit shared value from column and translate the
				// layout and alignment to css styles.
				var colData = cellInfo.columnModel.getColumnData(cellInfo.col) || {};

				// determine the behavior class to use.
				var linkClassName = this._linkClassName;
				switch (value.behavior || colData.behavior) {
					case "hoverUnderline":
					case "neverUnderline":
					case "alwaysUnderline":
						linkClassName += "-" + (value.behavior || colData.behavior);
						break;
				}

				// determine the color of the link.
				var linkCss = "";
				var color = value.color || colData.color;
				if (color)
					linkCss = "color:" + this._colorMgr.resolve(color);

				var htmlArr = [
					"<span role='link' class='", linkClassName, "' style='",
					linkCss,
					"'>",
					value.text,
					"</span>"
				];

				return htmlArr.join("");
			}

			return "";
		},
	}

});


/**
 * wisej.web.datagrid.cellRenderer.RowHeader
 *
 * Specialized cell renderer used for the row header cell.
 */
qx.Class.define("wisej.web.datagrid.cellRenderer.RowHeader", {

	extend: wisej.web.datagrid.cellRenderer.Cell,

	construct: function () {

		this.base(arguments);
	},

	statics: {

		DEFAULT_ERROR_CSS: "height:100%;position:absolute;left:0px;top:0px;width:0px;overflow:visible",
	},

	properties: {

		/**
		 * Appearance key for the cell renderer.
		 */
		appearance: { init: "table-row-header", refine: true },
	},

	members: {

		// overridden.
		// the row header is focused when the row is focused, doesn't need
		// also the column to be focused, like a normal cell.
		_getCellState: function (cellInfo) {

			var state = this.base(arguments, cellInfo);

			// focused?
			if (cellInfo.focusedRow) {

				state.focused = true;
			}

			// new row?
			var rowData = cellInfo.rowData;
			if (rowData && rowData.newRow)
				state.new = true;

			// is any cell in the row being edited?
			if (cellInfo.focusedRow && cellInfo.table && cellInfo.table.isEditing())
				state.editing = true;

			// right to left?
			if (cellInfo.rightToLeft)
				state.rightToLeft = true;

			return state;
		},

		/**
		 * Creates the additional css classes needed for this renderer.
		 */
		_registerCssClasses: function () {

			var styleMgr = this._styleMgr;
			var appearance = this.getAppearance();

			// error element.
			this._errorClassName = styleMgr.getCssClass(appearance + "/error", {}, wisej.web.datagrid.cellRenderer.RowHeader.DEFAULT_ERROR_CSS);

			// register the pseudo classes to support hovering since cannot handle it in the code because cells are not widgets.
			styleMgr.createCssPseudoClass(this._errorClassName + ":hover", appearance + "/error", { hovered: true }, "");

			this.base(arguments);
		}
	}
});
