///////////////////////////////////////////////////////////////////////////////
//
// (C) 2015 ICE TEA GROUP LLC - ALL RIGHTS RESERVED
//
// 
//
// ALL INFORMATION CONTAINED HEREIN IS, AND REMAINS
// THE PROPERTY OF ICE TEA GROUP LLC AND ITS SUPPLIERS, IF ANY.
// THE INTELLECTUAL PROPERTY AND TECHNICAL CONCEPTS CONTAINED
// HEREIN ARE PROPRIETARY TO ICE TEA GROUP LLC AND ITS SUPPLIERS
// AND MAY BE COVERED BY U.S. AND FOREIGN PATENTS, PATENT IN PROCESS, AND
// ARE PROTECTED BY TRADE SECRET OR COPYRIGHT LAW.
//
// DISSEMINATION OF THIS INFORMATION OR REPRODUCTION OF THIS MATERIAL
// IS STRICTLY FORBIDDEN UNLESS PRIOR WRITTEN PERMISSION IS OBTAINED
// FROM ICE TEA GROUP LLC.
//
///////////////////////////////////////////////////////////////////////////////


/**
 * wisej.mixin.MWisejComponent
 * 
 * All Wisej components must include this mixin to be recognized
 * by the Wisej.Core implementation.
 */
qx.Mixin.define("wisej.mixin.MWisejComponent", {

	/**
	 * construct
	 *
	 * Initializes the core reference to Wisej.Core.
	 */
	construct: function () {

		if (wisej.web.DesignMode) {
			this.core = {
				processingActions: false
			};
		}
		else {

			this.core = Wisej.Core;

			// set the "owner" and "container" attributes for QA automation.
			this.addListener("changeMenuVisibility", function (e) {
				var menu = e.getData();
				if (menu.isVisible()) {
					wisej.utils.Widget.setAutomationAttributes(menu, this);
				}
			});

			// when "automation.mode" is enabled, change the id of the element on creation.
			if (this instanceof qx.ui.core.Widget
				&& qx.core.Environment.get("automation.mode") === true) {
				this.addListenerOnce("appear", function (e) { wisej.utils.Widget.setAutomationID(this); });
			}
		}
	},

	/**
	 * destruct
	 * 
	 * - Removes the widget from our global registry.
	 * - Unregisters the widget from its container.
	 */
	destruct: function () {

		if (wisej.web.DesignMode) {

			if (wisej.web.DesignComponents)
				delete wisej.web.DesignComponents[this.getId()];

			return;
		}

		// unregister if not a control, otherwise
		// we call unregisterComponent twice.
		if (!this.isWisejControl)
			this.core.unregisterComponent(this);
	},

	properties: {

		/**
		 * The unique id of the widget, generated by the server.
		 */
		id: { init: null, check: "String", apply: "_applyId" },

		/**
		 * The name of the control set by the server.
		 * 
		 * This is a unique name within the container. It is also
		 * used to register a reference to the control in the container:
		 * 
		 *	i.e.: App.Window1.button1;
		 */
		name: { init: "", check: "String", apply: "_applyName", event: "changeName" },

		/**
		 * List of event descriptors defined by the server.
		 * 
		 * The events can be defined simply by the name and an optional argument name that
		 * will contain a data object with data related to the event.
		 * 
		 *		config.events = ["click", "tabactivated(NewTab)"];
		 */
		wiredEvents: { init: null, check: "Array", nullable: true, apply: "_applyWiredEvents" },
	},

	members: {

		/**
		 * Wisej marker.
		 */
		isWisejComponent: true,

		/**
		 * Wisej.Core reference.
		 */
		core: null,

		/**
		 * getTopLevelContainer
		 *
		 * Returns the container for this widget. It's either:
		 *
		 *  - MainPage
		 *  - Desktop
		 *  - Form
		 */
		getTopLevelContainer: function () {

			if (this.isWisejControl && this.isTopLevel())
				return this;

			if (this instanceof qx.ui.core.Widget) {
				var parent = this;
				for (parent = parent.getLayoutParent() ;
						parent != null && !(parent.isWisejControl && parent.isTopLevel()) ;
							parent = parent.getLayoutParent());

				return parent;
			}

			return null;
		},

		/**
		 * Converts a widget string id to a widget reference.
		 */
		_transformComponent: function (value) {

			if (value == null)
				return null;

			var component = null;
			if (typeof value !== "string") {

				// the value is already a widget?
				if (value instanceof qx.core.Object) {

					component = value;

				} else {

					// create the widgets from the configuration.
					var config = value;
					if (wisej.web.DesignMode) {

						component = this._createDesignTimeComponent(config);
					}
					else {

						// check if the configuration specifies an id and if
						// the component already exists, if it does, retrieve it and update it.
						var id = config.id;
						if (id)
							component = this.core.getComponent(id);

						// already exist? update it.
						if (component) {
							delete config.id;
							delete config.className;
							if (component.isWisejControl)
								component.setState(config);
							else
								component.set(config);
						}
						else {
							// otherwise create it.
							component = this.core.createComponent(config);
						}
					}
				}
			}
			else {

				// retrieve the widgets using the id.
				if (!wisej.web.DesignMode) {
					var id = value;
					component = this.core.getComponent(id);
				}
				else {

					// when in design mode, use the DesignComponents map.
					if (wisej.web.DesignComponents) {
						var id = value;
						component = wisej.web.DesignComponents[id];
					}
				}

			}

			return component;
		},

		/**
		 * Transforms the incoming collection of child widgets
		 * by converting the widget id to the widget instance.
		 */
		_transformComponents: function (value) {

			if (value == null || value.length == 0)
				return [];

			// list of json definitions?
			if (typeof value[0] != "string") {

				// collection of widgets?
				if (value[0] instanceof qx.core.Object) {

					value = value;

				} else {

					// create the widgets from the config data.
					var widgets = [];
					for (var i = 0; i < value.length; i++) {

						var widget = null
						var config = value[i];

						if (wisej.web.DesignMode)
							widget = this._createDesignTimeComponent(config);
						else
							widget = this.core.createComponent(config);

						if (widget)
							widgets.push(widget);

					}
					value = widgets;
				}
			}
			else {

				var widgets = [];

				if (!wisej.web.DesignMode) {

					// resolve the widget from the IDs.
					for (var i = 0; i < value.length; i++) {
						var widget = this.core.getComponent(value[i]);
						if (widget)
							widgets.push(widget);
					}
				}
				else {
					// when in design mode, use the DesignComponents map.
					if (wisej.web.DesignComponents) {
						for (var i = 0; i < value.length; i++) {
							var widget = wisej.web.DesignComponents[value[i]];
							if (widget)
								widgets.push(widget);
						}
					}
				}

				value = widgets;
			}

			return value;
		},

		/**
		 * Converts the menu id to a menu instance.
		 */
		_transformMenu: function (value) {

			if (typeof value === "string") {
				if (wisej.web.DesignMode) {
					value = null;
				}
				else {
					var id = value;
					value = this.core.getComponent(id);
				}
			}

			return value;
		},

		/**
		 * Makes the child component act as a subcomponent when the 
		 * appearance key is defined as "$parent/[child key]".
		 */
		_setChildAppearance: function (parent) {

			var key = this.getAppearance();

			if (key && key.indexOf("$parent/") == 0) {
				key = key.substr("$parent/".length);
				this.$$subcontrol = key;
				this.$$subparent = parent;
				this.syncAppearance();
			}
		},

		/**
		 * Applies the name property.
		 *
		 * Sets the name of the component in the dom.
		 */
		_applyName: function (value, old) {

			var el = this.getAccessibilityElement();
			if (el) {
				if (value)
					el.setAttribute("name", value, true);
				else
					el.removeAttribute("name", true);
			}

			if (el != null && el != this.getContentElement()) {
				el = this.getContentElement();
				if (value)
					el.setAttribute("name", value, true);
				else
					el.removeAttribute("name", true);
			}
		},

		// returns the element to use to set automation attributes.
		getAutomationElement: function () {

			if (this.getAutomationTarget) {
				var target = this.getAutomationTarget();
				if (target)
					return target.getContentElement();
			}

			return (this instanceof qx.ui.core.Widget) ? this.getContentElement() : null;
		},

		// returns the element to use to set accessibility attributes.
		getAccessibilityElement: function () {

			if (this.getAccessibilityTarget) {
				var target = this.getAccessibilityTarget();
				if (target)
					return target.getContentElement();
			}

			return (this instanceof qx.ui.core.Widget) ? this.getContentElement() : null;
		},

		/**
		 * Applies the id property.
		 * 
		 * Registers this widget in the global registry using
		 * the unique id as the key.
		 */
		_applyId: function (value, old) {

			if (this instanceof qx.ui.core.Widget) {
				var el = this.getContentElement();
				if (el)
					el.setAttribute("id", value);
			}

			if (!wisej.web.DesignMode)
				this.core.registerComponent(this);
		},

		/**
		 * The collection of wired event descriptors.
		 */
		__wiredEvents: null,

		/**
		* Applies the wired events property.
		* 
		* Parses the event descriptors and hook
		* an event handler for each event.
		* 
		* The event handler normalizes the event arguments
		* and passes them to Wisej.Core to send them back to
		* the server.
		*/
		_applyWiredEvents: function (value, old) {

			if (wisej.web.DesignMode)
				return;

			// ensure the collection of event handlers.
			this.__wiredEvents = this.__wiredEvents || {};

			// parse the descriptors
			var oldDescriptors = this.core.parseEventDescriptors(old);
			var newDescriptors = this.core.parseEventDescriptors(value);

			// detach previously attached event handlers
			var events = old;
			if (oldDescriptors != null) {

				for (var type in oldDescriptors) {

					// don't remove the old events  that are still in
					// the new list of wired events.
					if (newDescriptors && newDescriptors[type]) {
						delete newDescriptors[type];
						continue;
					}

					try {

						// remove the event handler.
						var handler = this.__wiredEvents[type];
						if (handler) {
							delete this.__wiredEvents[type];
							this.removeListener(type, handler, this);
						}
					}
					catch (error) {

						if (this.core)
							this.core.logError(error);
					}
				}
			}

			// attach the new event handlers.
			if (newDescriptors != null) {

				for (var type in newDescriptors) {

					var descr = newDescriptors[type];

					//
					// handler closure.
					//
					function makeHandler(descriptor) {

						// argument value converters.
						function convertData(data) {

							if (data == null)
								return;

							// wisej control? return the id.
							if (data.isWisejComponent)
								return data.getId();

							// primitive?
							if ((data instanceof String || data instanceof Date || data instanceof Boolean)
									|| ("string,number,boolean".indexOf(typeof data) > -1))
								return data;

							// array or map?
							if (data instanceof Array) {
								var array = null;
								for (var i = 0; i < data.length; i++) {
									var value = convertData(data[i]);
									if (value != null) {
										if (array == null)
											array = new Array();

										array.push(value);
									}
								}

								return array;
							}
							else {

								// don't serialize complex QX objects.
								if (data.classname && qx.Class.isDefined(data.classname))
									return null;

								var map = null;
								for (var name in data) {
									var value = convertData(data[name]);
									if (value != null) {
										if (map == null)
											map = {};

										map[name] = value;
									}
								}

								return map;
							}

							return null;
						};

						//
						// event handler.
						//
						function handler(ev) {

							var target = this;
							var type = ev.getType();

							// don't route any event back to the server
							// while the component is in the middle of updating its state.
							if (this.__inSetState)
								return;

							// find the original wisej target for the event.
							var originalTarget = wisej.utils.Widget.findWisejComponent(ev.getOriginalTarget());

							// dispatch bubbled events only to the actual target and not the bubbled up target, otherwise
							// a parent control will get the events on the child controls.
							if (originalTarget && originalTarget != target) {

								// these are the events that cannot fire when bubbled. others, like "drop", can.
								switch (type) {

									case "keyup":
									case "keydown":
									case "keypress":
									case "focusin":
									case "focusout":

										// if the event bubbled because the target is disabled, fire the
										// event to the new target and stop bubbling...
										if (!originalTarget.isEnabled() || originalTarget.hasState("inner")) {
											ev.stopPropagation();
											break;
										}

										// block the event.
										return;

									case "tap":
									case "dbltap":
									case "click":
									case "dblclick":
									case "mouseout":
									case "mouseover":
									case "mouseup":
									case "mousedown":
									case "mousemove":
									case "mousewheel":

										// if the event bubbled because the target is disabled or anonymous, fire the
										// event to the new target and stop bubbling...
										if (!originalTarget.isEnabled() || originalTarget.isAnonymous() || originalTarget.hasState("inner")) {
											ev.stopPropagation();
											break;
										}

										// block the event.
										return;
								}
							}

							// stop "keypress: when keyCode is a not a printable character.
							if (ev instanceof qx.event.type.KeySequence
								&& type == "keypress"
								&& wisej.utils.Widget.isInputKey(ev.getKeyIdentifier())) {
								return;
							}

							// normalize the event args
							// and assign them to the corresponding argument name.
							var args = null;

							if (descriptor.argNames.length > 0) {
								var data = ev.getData ? ev.getData() : null;
								var value = convertData(data);
								args = args || {};
								args[descriptor.argNames[0]] = value;
							}

							// add standard arguments
							if (ev.getButton) {
								var button = 0
								switch (ev.getButton()) {
									case "right": button = 2; break;
									case "middle": button = 1; break;
								}
								args = args || {};
								args.button = button;
								args.modifiers = ev.getModifiers();
							}
							if (ev.getDocumentTop) {
								args = args || {};
								args.y = ev.getDocumentTop() | 0;
								args.x = ev.getDocumentLeft() | 0;
							}

							// detect the keyboard
							if (ev.getKeyCode) {
								args = args || {};
								args.keyCode = ev.getKeyCode();
								args.key = ev.getKeyIdentifier();
								args.modifiers = ev.getModifiers();
							}
							else if (window.event instanceof KeyboardEvent) {
								args = args || {};
								args.key = window.event.keyIdentifier;
								args.keyCode = window.event.keyCode || window.event.charCode;
								args.modifiers =
									window.event.shiftKey ? 1 : 0
									| window.event.ctrlKey ? 2 : 0
									| window.event.altKey ? 4 : 0
									| window.event.metaKey ? 8 : 0;
							}

							// mouse wheel.
							if (ev.getWheelDelta) {
								args = args || {};
								args.wheelDelta = ev.getWheelDelta() | 0;
							}

							// add the original target, if any.
							if (originalTarget != null && originalTarget != target) {
								args = args || {};
								args.originalId = originalTarget.getId();
							}

							// detect the role of the element that caused the event.
							if (ev.getNativeEvent) {
								var role = wisej.utils.Widget.getTargetRole(ev.getOriginalTarget());
								if (role) {
									args = args || {};
									args.role = role;
								}
							}

							// add custom event data.
							// used to pass information about the a drag drop target
							// but it can be used for other purposed.
							var eventData = ev.getUserData("eventData");
							if (eventData != null) {
								args = args || {};
								args.eventData = eventData;
								ev.setUserData("eventData", null);
							}

							this.core.fireEvent(target.getId(), descriptor.type, args, target);
						}
						return handler;
					}

					// attach the handler closure to the event
					var handler = makeHandler(descr);
					this.addListener(type, handler, this);
					this.__wiredEvents[type] = handler;
				}
			}
		},

		/**
		 * Checks if the event is wired to the server.
		 */
		isWired: function (type) {

			return this.__wiredEvents && this.__wiredEvents[type];
		},

		/**
		 * Destroys all the child controls.
		 *
		 * @param state {Object} optional container. If not specified, "this" is the container.
		 */
		destroyChildren: function (container) {

			var container =
				(container == null) ? this : container;

			if (!container.getChildren || !container.remove)
				return;

			// destroy all direct child controls in reverse order.
			var children = container.getChildren().concat();
			for (var i = children.length - 1; i >= 0; i--) {

				var c = children[i];

				// don't destroy child controls.
				if (c.$$subcontrol != null)
					continue;

				container.remove(c);

				if (c.destroy)
					c.destroy();
				else
					c.dispose();
			}
		},

		/**
		 * Creates a design time component.
		 *
		 * @param config {Map} Configuration map to create the component.
		 */
		_createDesignTimeComponent: function (config) {

			if (!config)
				return null;

			// find the widget class
			var className = config.className;
			delete config.className;
			if (!className)
				throw new Error("Null class name.");

			var widgetClass = qx.Class.getByName(className);
			if (!widgetClass)
				throw new Error("Unknown class name: " + className);

			try {

				// create the QX component.
				var comp = new widgetClass();

				delete config.root;
				delete config.webMethods;

				comp.set(config);

				// store in the design-time map.
				wisej.web.DesignComponents = wisej.web.DesignComponents || {};
				wisej.web.DesignComponents[comp.getId()] = comp;
			}
			catch (e) {

				alert(e.message);
			}

			// done
			return comp;
		},

	},
});


/**
 * wisej.mixin.MBackgroundImage
 * 
 * Adds support for multiple background images to the widget.
 */
qx.Mixin.define("wisej.mixin.MBackgroundImage", {

	construct: function () {

		// subclass the syncWidget method.
		this.__syncWidgetBase = this.syncWidget;
		this.syncWidget = this._syncWidget;

		// rightToLeft support.
		this.addListener("changeRtl", function (e) {

			if (e.getData() != e.getOldData())
				this._updateBackgroundImages();

		}, this);
	},

	destruct: function () {

		// remove the css rule associated with this component.
		var stylesheet = wisej.mixin.MBackgroundImage.__stylesheet;

		if (stylesheet) {
			var selector = ".wisej-background-" + this.$$hash;
			qx.bom.Stylesheet.removeRule(stylesheet, selector + "::after");
		}

	},

	properties: {

		/**
		 * Background images to assign to the widget.
		 *
		 * This property can be an array or a single value. It is a map expecting these fields:
		 *
		 *	- image: image source,
		 *	- layout: "none", "tile", "center", "stretch", "zoom", "bestFit", "originalSize",
		 *	- align: "topRight", "middleRight", "bottomRight", "topLeft", "topCenter", "middleLeft", "middleCenter", "bottomLeft", "bottomCenter"
		 *	- size: {width, height}
		 */
		backgroundImages: {
			init: null,
			nullable: true,
			apply: "_applyBackgroundImages",
			transform: "_transformBackgroundImages"
		},
	},

	statics: {

		// the stylesheet used for all background images.
		__stylesheet: null,

	},

	members: {

		// saves a reference to the widget's syncWidget method.
		__syncWidgetBase: null,

		/**
		 * Transforms incoming values for the backgroundImage property:
		 *
		 *	- Single values are converted to arrays.
		 */
		_transformBackgroundImages: function (value) {

			if (value) {
				if (!(value instanceof Array))
					value = [value];
			}

			return value;
		},

		/**
		 * Returns the actual list of background images to render.
		 *
		 * Widgets using this mixin have the option to implement
		 * the _getBackgroundImages() method to return a new list of 
		 * images without changing the property backgroundImages.
		 */
		getRealBackgroundImages: function () {

			if (this._getBackgroundImages)
				return this._getBackgroundImages();
			else
				return this.getBackgroundImages();
		},

		/**
		 * Applies the backgroundImage property.
		 */
		_applyBackgroundImages: function (value, old) {

			if (value || old)
				this._updateBackgroundImages();
		},

		_updateBackgroundImages: function () {

			qx.ui.core.queue.Widget.add(this, "updateBackgroundImages");
		},

		_syncWidget: function (jobs) {

			this.__syncWidgetBase(jobs);

			if (!jobs || !jobs["updateBackgroundImages"])
				return;

			this.__updateBackgroundImagesImpl();
		},

		__updateBackgroundImagesImpl: function () {

			var images = this.getRealBackgroundImages();
			var count = images != null ? images.length : 0;
			if (count > 0) {

				var imageUtils = qx.ui.basic.Image;
				var imageLoader = qx.io.ImageLoader;

				// resolve the image aliases and
				// wait for the images to be loaded before updating the control.
				var me = this;
				for (var i = 0; i < images.length; i++) {

					var item = images[i];

					if (item && item.image) {

						// resolves the image URI into a {source, color} map.
						var imageColor = imageUtils.resolveImage(item.image, this.getTextColor());

						if (imageColor.source) {
							item.image = imageColor.source;
							imageLoader.load(item.image, function (url, entry) {

								count--;

								if (entry.loaded) {

									// change the svg image color, if specified either in the image source url or as the widget's text color.
									if (imageColor.color) {
										var svg = imageLoader.getSvg(item.image);
										if (svg) {
											item.image = imageUtils.getSvgDataUri(imageUtils.setSvgColor(svg, imageColor.color));
										}
									}
								}

								// update the css rules once all images have been loaded.
								if (count == 0)
									me.__updateBackgroundCssRule(images);
							});
						}
					}
					else {
						count--;
					}
				}

				// update the css rules once all images have been loaded.
				if (count == 0)
					this.__updateBackgroundCssRule(images);
			}
			else {
				this.__updateBackgroundCssRule(images);
			}
		},

		// updates the css rule linked to this component to 
		// render the background images.
		__updateBackgroundCssRule: function (images) {

			if (images == null) {
				this.__removeBackgroundCssRule();
				return;
			}

			var target = this.__getTarget();
			var styles = this.__buildCssStyles(images);
			var cssRuleAfter = this.__getCssRule(target, "::after").style;

			for (var name in styles) {
				cssRuleAfter[name] = styles[name];
			}

			// update the padding.
			var padding =
				target.getPaddingTop() + "px " +
				target.getPaddingRight() + "px " +
				target.getPaddingBottom() + "px " +
				target.getPaddingLeft() + "px"

			cssRuleAfter.padding = padding;
		},

		__removeBackgroundCssRule: function () {

			var target = this.__getTarget();
			var el = target.getContentElement();
			if (el)
				el.removeClass(this.__getBackgroundClassName());
		},

		__getTarget: function () {
			var target =
				this._getBackgroundWidget
					? this._getBackgroundWidget()
					: this.getChildControl("pane", true);

			if (target == null)
				target = this;

			return target;
		},

		__getBackgroundClassName: function () {
			return "wisej-background-" + this.$$hash;
		},

		__buildCssStyles: function (images) {

			var style = {
				boxSizing: null,
				backgroundSize: [],
				backgroundImage: [],
				backgroundRepeat: [],
				backgroundOrigin: [],
				backgroundPosition: [],
			};

			if (images && images.length > 0) {

				for (var i = 0; i < images.length; i++) {
					this.__setBackgroundImageStyle(style, images[i]);
				}

				style.backgroundSize = style.backgroundSize.join(",");
				style.backgroundImage = style.backgroundImage.join(",");
				style.backgroundRepeat = style.backgroundRepeat.join(",");
				style.backgroundOrigin = style.backgroundOrigin.join(",");
				style.backgroundPosition = style.backgroundPosition.join(",");
			}
			else {
				style.boxSizing = null;
				style.backgroundSize = null;
				style.backgroundImage = null;
				style.backgroundRepeat = null;
				style.backgroundOrigin = null;
				style.backgroundPosition = null;
			}

			return style;
		},

		__setBackgroundImageStyle: function (styles, image) {

			if (image == null || !image.image)
				return;

			var imageSize;
			if (image.size) {
				if (typeof image.size === "string")
					imageSize = image.size;
				else if (image.size.width && image.size.height)
					imageSize = image.size.width + "px " + image.size.height + "px";
				else if (image.size.width)
					imageSize = image.size.width + "px";
				else if (image.size.height)
					imageSize = image.size.height + "px";
			}
			if (!imageSize) {
				// try to read the background size from the current theme.
				var decorator = qx.theme.manager.Decoration.getInstance().resolve(this.getDecorator());
				if (decorator)
					imageSize = decorator.getStyles().backgroundSize;
			}
			if (!imageSize) {
				imageSize = "auto";
			}

			styles.backgroundImage.push("url(\"" + image.image + "\")");

			if (image.layout && image.layout != "none") {

				styles.boxSizing = "border-box";
				styles.backgroundOrigin.push("padding-box");

				switch (image.layout) {

					case "tile":
						styles.backgroundSize.push(imageSize);
						styles.backgroundRepeat.push("repeat");
						styles.backgroundPosition.push("left top");
						break;

					case "stretch":
						styles.backgroundSize.push("100% 100%");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push("center");
						break;

					case "center":
						styles.backgroundSize.push(imageSize);
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push("center center");
						break;

					case "zoom":
						styles.backgroundSize.push("cover");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push("center");
						break;

					case "bestFit":
						styles.backgroundSize.push("contain");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push(this.__translateImageAlign(image.align));
						break;

					case "originalSize":
						styles.backgroundSize.push("auto");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push(this.__translateImageAlign(image.align));
						break;
				}
			}
			else {

				styles.backgroundSize.push(imageSize);

				if (image.align) {

					styles.boxSizing = "border-box";
					styles.backgroundRepeat.push("no-repeat");
					styles.backgroundOrigin.push("content-box");
					styles.backgroundPosition.push(this.__translateImageAlign(image.align));
				}
			}
		},

		__translateImageAlign: function (value) {

			if (!value)
				return "center";

			var left = this.isRtl() ? "right" : "left";
			var right = this.isRtl() ? "left" : "right";

			switch (value) {
				case "topRight": return "top " + right;
				case "middleRight": return "center " + right;
				case "bottomRight": return "bottom " + right;
				case "topLeft": return "top " + left;
				case "topCenter": return "top center";
				case "middleLeft": return "center " + left;
				case "middleCenter": return "center";
				case "bottomLeft": return "bottom " + left;
				case "bottomCenter": return "bottom center";
				default: return "center";
			}
		},

		__getCssRule: function (target, pseudo) {

			var stylesheet = null;
			var firstTime = false;

			// create the shared stylesheet.
			var stylesheet = wisej.mixin.MBackgroundImage.__stylesheet;
			if (!stylesheet) {
				firstTime = true;
				stylesheet = qx.bom.Stylesheet.createElement("");
				wisej.mixin.MBackgroundImage.__stylesheet = stylesheet;
			}

			// find the selector that matches this component and the pseudo element, if specified.
			var className = this.__getBackgroundClassName();
			var selector = "." + className + pseudo;

			var rules = stylesheet.cssRules;
			var count = rules.length;
			for (var i = 0; i < count; i++) {

				var rule = rules[i];
				if (rule.selectorText == selector) {
					var el = target.getContentElement();
					if (el)
						el.addClass(className);
					return rule;
				}
			}

			var el = target.getContentElement();
			if (el == null)
				return null;

			// create the css rule.
			var padding =
				target.getPaddingTop() + "px " +
				target.getPaddingRight() + "px " +
				target.getPaddingBottom() + "px " +
				target.getPaddingLeft() + "px"

			qx.bom.Stylesheet.addRule(stylesheet,
				selector,
				"content:\"\"; display:block;position:absolute;top:0px;left:0px;width:100%;height:100%;z-index:-1;padding:" + padding);

			// assign the class to this element.
			el.addClass(className);

			// attach to the change of the padding to copy the padding to the
			// background image overlay :after element.
			if (firstTime) {
				this.addListener("changePadding", function (e) {

					var cssRuleAfter = this.__getCssRule(target, "::after").style;
					if (cssRuleAfter) {

						// update the padding.
						var padding =
							target.getPaddingTop() + "px " +
							target.getPaddingRight() + "px " +
							target.getPaddingBottom() + "px " +
							target.getPaddingLeft() + "px"

						cssRuleAfter.padding = padding;
					}
				});

				// detect changes the text color to update the fill on svg background images.
				this.addListener("changeTextColor", function (e) {
					this._updateBackgroundImages();
				});
			}

			return this.__getCssRule(target, pseudo);
		},

		__removeCssRule: function (target, pseudo) {

			// create the shared stylesheet.
			var stylesheet = wisej.mixin.MBackgroundImage.__stylesheet;
			if (stylesheet) {
				var selector = "." + this.__getBackgroundClassName() + pseudo;
				qx.bom.Stylesheet.removeRule(stylesheet, selector);
			}
		},
	}
});


/**
 * wisej.mixin.MWisejControl
 * 
 * All Wisej controls must include this mixin to be recognized
 * by the Wisej.Core implementation.
 */
qx.Mixin.define("wisej.mixin.MWisejControl", {

	include: [
		wisej.mixin.MWisejComponent,
		wisej.mixin.MBackgroundImage,
		qx.ui.core.MResizable,
		qx.ui.core.MMovable],

	/**
	 * construct
	 *
	 * Initialize properties, add listeners to keep mapped properties in sync, add
	 * design time render listener, initialize movable/resizable common state.
	 */
	construct: function () {

		// initialize state events.
		this.initStateEvents();

		// widgets cannot be resized or moved on the client by default.
		this.setMovable(false);
		this.setResizable(false);

		// all wisej controls can shrink and grow.
		this.setAllowGrowX(true);
		this.setAllowGrowY(true);
		this.setAllowShrinkX(true);
		this.setAllowShrinkY(true);

		// when in design mode, invoke this.__onDesignRender to let
		// the widget being designed fire the "render" event in order
		// to notify the designer that it's ready to be rendered.
		//
		// otherwise, register this widget with the html5 drag-drop manager.
		//
		this.addListenerOnce("appear", function (e) {

			if (wisej.web.DesignMode) {

				this.__onDesignRender(e);
			}
			else {

				// register this widget for the native html5 file drag-drop handling.
				var dragDrop = wisej.web.DragDrop.getInstance();
				if (dragDrop)
					dragDrop.registerComponent(this);
			}
		});
	},

	/**
	 * destruct
	 * 
	 * - Removes the widget from our global registry.
	 * - Unregisters the widget from its container.
	 */
	destruct: function () {

		if (wisej.web.DesignMode)
			return;

		// remove all wisej wired handlers.
		this.setWiredEvents(null);

		var parent = this.getParent();

		// unregister from the "App" namespace.
		if (this.isTopLevel())
			this.core.unregisterComponent(this, window.App);

		// unregister from parent and clear the parent reference.
		if (parent) {

			this.core.unregisterComponent(this, parent);

			qx.util.PropertyUtil.setUserValue(this, "parent", null);
		}
	},

	properties: {

		/**
		 * The X location of the control within its parent.
		 * 
		 * Property defined with the setter/getter methods.
		 */
		// x: { init: 0, check: "Integer" },

		/**
		 * The Y location of the control within its parent.
		 * 
		 * Property defined with the setter/getter methods.
		 */
		// y: { init: 0, check: "Integer" },

		/**
		 * Indicates that the component is "dirty"
		 * and needs to send its new state back to the server.
		 *
		 * Property defined with the setter/getter methods.
		 */
		// dirty: { init: false, check: "Boolean" },

		/**
		 * Collection of child controls.
		 *
		 * The collection always contains an array of widgets.
		 * 
		 * The incoming value can be:
		 *
		 *		- Array of widget instances.  
		 *		- Array of IDS. In which case all the widgets must have been created already.
		 *		- Array of widget definitions, that is the JSON definition of the widgets.
		 *
		 * Property defined with the setter/getter methods.
		 */
		// controls: { init: null, check: "Array", apply: "_applyControls", transform: "_transformComponents" },

		/**
		 * Signals that the controls collection must be added in reverse order.
		 */
		reverseControls: { init: true, check: "Boolean" },

		/**
		 *  ImeMode.
		 *
		 * Sets the ime-mode css style.
		 */
		imeMode: { init: null, nullable: true, check: "String", apply: "_applyImeMode" },

		/**
		 * The visible property.
		 * 
		 * Property defined with the setter/getter methods.
		 */
		// visible: { init: false, check: "Boolean", apply: "setVisible" },

		/**
		 * MouseCapture property.
		 * 
		 * When set to true, the widget captures all mouse events.
		 */
		mouseCapture: { init: false, check: "Boolean", apply: "_applyMouseCapture" },

		/**
		 * ResizableEdges property.
		 * 
		 * Sets the resizable edges of the control.
		 * The value is an array: ["left", "top", "right", "bottom"].
		 */
		resizableEdges: { init: null, check: "Array", apply: "_applyResizableEdges", nullable: true, event: "changeResizableEdges" },

		/**
		 * Movable property.
		 * 
		 * When set to true, the widget can be dragged on the screen.
		 */
		allowMove: { init: false, check: "Boolean", apply: "_applyAllowMove", event: "changeAllowMove" },

		/**
		 * The childIndex property.
		 *
		 * Property defined with the setter/getter methods. It needs to be called also when the value is not changed
		 * since the z-index or childIndex is relative to the other siblings.
		 */
		// childIndex: { init: 0, check: "PositiveInteger", apply: "_applyChildIndex", event: "changeChildIndex" },

		/**
		 * TabStop property.
		 *
		 * Determines whether the control can be focused in the tab order.
		 */
		tabStop: { init: false, check: "Boolean", apply: "_applyTabIndex" },

		/**
		 * The parent widget.
		 * 
		 * This is not the layout parent as defined by QX, this is the parent
		 * defined by the server code.
		 *
		 * The incoming value can be the widget ID or the widget instance.
		 */
		parent: { init: null, apply: "_applyParent", nullable: true, transform: "_transformComponent" },

		/**
		 * The contextual menu.
		 * 
		 * Replaces the built-in contextMenu.
		 */
		contextMenu: { init: null, nullable: true, apply: "_applyContextMenu", transform: "_transformMenu" },

		/**
		 * Indicates that the control is a top level
		 * window, that is usually a form, a page or a dialog box.
		 */
		topLevel: { init: false, check: "Boolean", apply: "_applyTopLevel" },

		/**
		 * Accessibility property.
		 *
		 * Sets the combination  of accessibility attributes on the current element:
		 *
		 *    name = the name attributes.
		 *    description = the alt attribute.
		 *    role = the role attribute.
		 */
		accessibility: { init: null, check: "Map", apply: "_applyAccessibility" },

		/**
		 * EnableTouchEvents property.
		 *
		 * When true, we attach to the touch events and convert them to data events
		 * that can be managed by the server.
		 */
		enableTouchEvents: { init: false, check: "Boolean", apply: "_enableTouchEvents" },

		/**
		 * List of properties that should be included in the state.
		 */
		stateProperties: { init: ["x", "y", "width", "height", "visible", "enabled"], check: "Array", nullable: true },

		/**
		 * List of events that causes this component to be marked dirty.
		 */
		stateEvents: { init: ["move", "resize", "changeVisibility", "changeEnabled"], check: "Array", apply: "_applyStateEvents", nullable: true },
	},

	members: {

		/**
		 * Wisej marker.
		 */
		isWisejControl: true,

		// indicates that the component is in the middle
		// of updating its state.
		__inSetState: false,

		/**
		 * updateState
		 *
		 * Updates the state of the component and returns the difference
		 * with the previous state.
		 */
		updateState: function () {

			if (wisej.web.DesignMode)
				return;

			var properties = this.getStateProperties();
			if (properties == null)
				return;

			// build the state using the state properties
			var state = {};
			for (var i = 0; i < properties.length; i++) {

				try {
					var name = properties[i];

					var value = this.get(name);

					// clone objects to break the reference.
					if (value instanceof Object && (!value instanceof qx.ui.core.Widget))
						value = qx.lang.Object.clone(value, true);

					state[name] = value;
				}
				catch (error) {

					if (this.core)
						this.core.logError(error);
				}
			}

			// let the widget handle the collected state.
			if (this.getState)
				state = this.getState(state);

			// update the saved state and return the difference.
			var diffState = this.core.diffState(this.$state, state);
			if (diffState)
				diffState.id = this.getId();

			this.$state = state;
			return diffState;
		},

		/**
		 * resetState
		 *
		 * Clears the saved state. The next call to updateState()
		 * will return the full state of the component.
		 */
		resetState: function () {

			this.$state = null;

		},

		/**
		 * Applies the state.
		 *
		 * Updates the component state.
		 *
		 * @param state {Map} state properties.
		 */
		setState: function (state) {

			// update the component and the stored state.
			this.__inSetState = true;
			try {

				this.set(state);
				this.updateState();

			} catch (error) {

				if (this.core)
					this.core.logError(error);
			}
			this.__inSetState = false;
		},

		/**
		 * showLoader
		 *
		 * Blocks the component and shows a modal mask
		 * with the themed loader "ajax-loader".
		 */
		showLoader: function () {

			if (this.isWisejControl) {

				var loader = this.$$loader;
				if (loader == null) {

					loader = this.$$loader = new qx.ui.core.Blocker(this);

					loader.addListener("unblocked", function (e) {
						if (this.$$loader) {
							this.$$loader.dispose();
							this.$$loader = null;
						}
					}, this);
				}

				loader.block();
				loader.setColor("loaderBackground");
				loader.setLoaderImage("ajax-loader");

			}
		},

		/**
		 * hideLoader
		 *
		 * Unblocks the component when the blocking count reaches zero.
		 */
		hideLoader: function () {

			var loader = this.$$loader;
			if (loader != null)
				loader.unblock();
		},

		/**
		 * Returns whether the widget is reachable by pressing the TAB key.
		 *
		 * Tests for both, the focusable property and a positive or
		 * undefined tabIndex property. The widget must have a DOM element
		 * since only visible widgets are tabable.
		 */
		isTabable: function () {

			// having a DOM element is not enough, hidden widgets have a DOM element too.
			var dom = this.getContentElement().getDomElement();
			if (!dom || dom.offsetWidth == 0)
				return false;

			// not tabable if an UserControl widget in the parent path has tabStop = false.
			for (var parent = this.getParent() ; parent != null; parent = parent.getParent()) {
				if (parent instanceof wisej.web.UserControl && !parent.isTabStop())
					return false;
			}

			return this.isTabStop() && this.isFocusable();
		},

		/**
		 * Gets/Sets the dirty property.
		 */
		getDirty: function () {

			if (wisej.web.DesignMode)
				return false;

			return this.core.isDirty(this);
		},
		setDirty: function (value) {

			if (wisej.web.DesignMode)
				return;

			this.core.setDirty(this, value);
		},

		/**
		 * Gets/Sets the visible property.
		 */
		getVisible: function () {
			return this.getVisibility() === "visible";
		},
		setVisible: function (value) {
			this.setVisibility(value ? "visible" : "excluded");
		},

		/**
		 * Applies the childIndex property.
		 */
		getChildIndex: function () {

			var parent = this.getParent();
			if (!parent)
				return 0;

			var children = parent.getChildren();
			var index = children.indexOf(this);

			if (parent.isReverseControls()) {
				var count = children.length;
				index = count - index - 1;
			}
			return index;
		},
		setChildIndex: function (value) {

			var parent = this.getParent();
			if (parent) {

				var index = value;
				var currentIndex = this.getChildIndex();
				var count = parent.getControls().length;
				index = Math.max(0, Math.min(index, count - 1));

				if (index == currentIndex)
					return;

				var forward = (index < currentIndex);

				if (parent.isReverseControls()) {
					// we must keep the child index in reverse order
					// since the dom element order is the opposite of z-order.
					index = count - index - 1;
					index = Math.max(0, index);
				}

				if (parent.addAt)
					parent.addAt(this, index);
				else
					parent._addAt(this, index);

				// update the dom order.
				var thisEl = this.getContentElement();
				if (thisEl) {
					var domIndex = index + (forward ? 1 : 0);
					thisEl.moveTo(domIndex);
				}

				this.fireDataEvent("changeChildIndex", index, currentIndex);
			}
		},

		/**
		 * Applies the TabIndex property.
		 */
		_applyTabIndex: function (value) {

			if (this.isWisejContainer)
				return;

			if (this.isTabStop() && value > 0)
				this.getFocusElement().setAttribute("tabIndex", value);
			else
				this.getFocusElement().removeAttribute("tabIndex");
		},

		/**
		 * Captures the mouse.
		 */
		_applyMouseCapture: function (value, old) {
			this.capture(value);
		},

		/**
		 * Applies the ime-mode css.
		 */
		_applyImeMode: function (value, old) {

			var elem = this.getContentElement();
			elem.setStyle("imeMode", value);
		},

		/**
		 * Sets the resizable edges.
		 */
		_applyResizableEdges: function (value, old) {

			var edges = [false, false, false, false];

			if (value) {
				for (var i = 0; i < value.length; i++) {
					switch (value[i]) {
						case "top": edges[0] = true; break;
						case "left": edges[3] = true; break;
						case "right": edges[1] = true; break;
						case "bottom": edges[2] = true; break;
					}
				}
			}

			this.setResizable(edges);
		},

		/**
		 * Allows the widget to be moved across the screen.
		 */
		_applyAllowMove: function (value, old) {

			if (value == old)
				return;

			this.setMovable(value);

			if (value && this.__moveHandle == null)
				this._activateMoveHandle(this);

			// allow the child widget to be dragged on android touch devices.
			if (!this.isTopLevel()) {

				var el = this.getContentElement();
				if (value)
					el.setStyles({ "touch-action": "none", "-ms-touch-action": "none" });
				else if (!this.getEnableTouchEvents())
					el.setStyles({ "touch-action": "none", "-ms-touch-action": "none" });
			}

		},

		/**
		 * Applies the topLevel property.
		 * 
		 * TopLevel components are registered in the global namespace.
		 */
		_applyTopLevel: function (value, old) {

			if (wisej.web.DesignMode)
				return;

			// make sure we have the App instance.
			window.App = window.App || {};

			// unregister, if previously registered as a child control
			if (old)
				this.core.unregisterComponent(this, window.App);

			// re-register as a top-level control.
			if (value)
				this.core.registerComponent(this, window.App);
		},

		/**
		 * Applies the accessibility attributes.
		 */
		_applyAccessibility: function (value, old) {

			var el = this.getAccessibilityElement();
			if (el) {

				if (value) {
					el.setAttributes({
						name: value.name,
						alt: value.description,
						role: value.role.toLowerCase()
					});
				}
				else {
					el.setAttributes({
						alt: null,
						name: null,
						role: null,
					});
				}
			}
		},

		/**
		 * Applies the enableTouchEvents property.
		 */
		_enableTouchEvents: function (value, old) {

			var el = this.getContentElement();

			if (value) {

				this.addListener("touchstart", this.__onTouchEvent);
				this.addListener("touchend", this.__onTouchEvent);
				this.addListener("touchcancel", this.__onTouchEvent);
				this.addListener("touchmove", this.__onTouchEvent);
				this.addListener("swipe", this.__onTouchEvent);
				this.addListener("pinch", this.__onTouchEvent);
				this.addListener("track", this.__onTouchEvent);
				this.addListener("rotate", this.__onTouchEvent);

				if (!this.isMovable())
					el.setStyles({ "touch-action": "none", "-ms-touch-action": "none" });

			}
			else {
				this.removeListener("touchstart", this.__onTouchEvent);
				this.removeListener("touchend", this.__onTouchEvent);
				this.removeListener("touchcancel", this.__onTouchEvent);
				this.removeListener("touchmove", this.__onTouchEvent);
				this.removeListener("swipe", this.__onTouchEvent);
				this.removeListener("pinch", this.__onTouchEvent);
				this.removeListener("track", this.__onTouchEvent);
				this.removeListener("rotate", this.__onTouchEvent);

				el.setStyles({ "touch-action": null, "-ms-touch-action": null });
			}
		},

		// Converts native/qooxdoo touch event arguments into a data package for
		// wisej to be able to route the event to the control.
		__onTouchEvent: function (e) {

			// find the original wisej target for the event.
			var originalTarget = wisej.utils.Widget.findWisejComponent(e.getOriginalTarget());

			// dispatch bubbled events only to the actual target and not the bubbled up target, otherwise
			// a parent control will get the events on the child controls.
			if (originalTarget && originalTarget != this && !originalTarget.hasState("inner"))
				return;

			switch (e.getType()) {

				case "touchstart":
					this.fireDataEvent("touch.start", this.__getTouchData(e));
					break;

				case "touchend":
					this.fireDataEvent("touch.end", this.__getTouchData(e));
					break;

				case "touchcancel":
					this.fireDataEvent("touch.cancel", this.__getTouchData(e));
					break;

				case "touchmove":
					this.fireDataEvent("touch.move", this.__getTouchData(e));
					break;

				case "pinch":
					this.fireDataEvent("touch.pinch", e.getScale());
					break;

				case "swipe":
					this.fireDataEvent("touch.swipe", {
						axis: e.getAxis(),
						startTime: e.getStartTime(),
						duration: e.getDuration(),
						direction: e.getDirection(),
						velocity: e.getVelocity(),
						distance: e.getDistance()
					});
					break;

				case "rotate":
					this.fireDataEvent("touch.rotate", e.getAngle());
					break;

				case "track":
					this.fireDataEvent("touch.track", e.getDelta());
					break;
			}

		},

		// Extract usable data from the touch event.
		__getTouchData: function (e) {

			var list = [];
			var touches = e.getTargetTouches();
			for (var i = 0; i < touches.length; i++) {
				list.push({
					id: e.getIdentifier(i),
					screenX: e.getDocumentLeft(i) | 0,
					screenY: e.getDocumentTop(i) | 0,
				});
			}

			return {
				touches: list,
				scale: e.getScale(),
				rotation: e.getRotation(),
				multiTouch: e.isMultiTouch()
			};

		},

		/**
		 * Applies the controls property.
		 * 
		 * Sets this widget as the parent of each child
		 * and adds the child control to this widget"s
		 * children container.
		 */
		getControls: function () {

			return this.getChildren
				? this.getChildren()
				: this._getChildren();
		},
		setControls: function (value) {

			var old = this.getControls();
			var controls = this._transformComponents(value);

			// remove all existing child widgets that are not present in the new collection.
			if (old != null && old.length > 0) {

				// dereference the children array or the loop
				// will skip widgets as it shrinks.
				old = old.concat();

				for (var i = 0; i < old.length; i++) {
					var child = old[i];
					if (child != null && child.isWisejControl) {
						if (controls && controls.indexOf(child) == -1)
							child.setParent(null);
					}
				}
			}

			if (controls != null && controls.length > 0) {

				// assign the parent to the widgets in the collection in reverse order
				// to keep the z-order in sync with the collection order on the server.
				if (this.isReverseControls()) {

					for (var i = controls.length - 1; i > -1; i--) {
						var child = controls[i];
						if (child != null && child.isWisejControl)
							child.setParent(this);
					}
				}
				else {

					for (var i = 0; i < controls.length; i++) {
						var child = controls[i];
						if (child != null && child.isWisejControl)
							child.setParent(this);
					}
				}
			}

			this.fireEvent("controlsChanged");
		},

		/**
		 * Applies the contextMenu property.
		 */
		_applyContextMenu: function (value, old) {

			if (old) {
				old.removeState("contextmenu");

				if (old.getOpener() == this) {
					old.resetOpener();
				}
			}

			if (value) {

				value.setOpener(this);
				value.addState("contextmenu");

				if (!old) {
					this.addListener("longtap", this._onContextMenuOpen, this);
					this.addListener("contextmenu", this._onContextMenuOpen, this);
				}

				// rightToLeft support.
				value.setRtl(this.getRtl());
			}
			else {
				this.removeListener("longtap", this._onContextMenuOpen, this);
				this.removeListener("contextmenu", this._onContextMenuOpen, this);
			}
		},

		/**
		 * Gets/Sets the "x" (left) property.
		 */
		getX: function () {

			return this.getLayoutProperties().left;
		},
		setX: function (value) {

			this.setLayoutProperties({ left: value });
			this.__updateUserBounds();
		},

		/**
		 * Gets/Sets the "y" (top) property.
		 */
		getY: function () {

			return this.getLayoutProperties().top;
		},
		setY: function (value) {

			this.setLayoutProperties({ top: value });
			this.__updateUserBounds();
		},

		// overridden.
		_applyDimension: function (value, old, name) {

			switch (name) {
				case "width":
				case "height":
					this.__updateUserBounds();
					break;
			}

			qx.ui.core.queue.Layout.add(this);
		},

		// update the user bounds when this is a child control
		// that is not inside a wisej container.
		//
		// Note: Wisej containers are widgets that are marked with the
		// isWisejContainer member set to true. Containers manage their own
		// internal layout and child widgets should not set their user bounds.
		__updateUserBounds: function () {

			var parent = this.getParent();
			if (parent != null && !parent.isWisejContainer) {

				var top = this.getY();
				if (top == null)
					return;

				var left = this.getX();
				if (left == null)
					return;

				var width = this.getWidth();
				if (width == null)
					return;

				var height = this.getHeight();
				if (height == null)
					return;

				this.setUserBounds(left, top, width, height);
			}
		},

		/**
		 * Applies the parent property.
		 * 
		 * Saves a reference to the parent widget
		 * and registers this widget in the parent"s namespace.
		 */
		_applyParent: function (value, old) {

			// in case we are changing the parent,
			// unregister the component from the global namespace
			// and remove it from the parent's children.
			if (old) {

				if (!wisej.web.DesignMode)
					this.core.unregisterComponent(this, old);

				try {

					if (old.indexOf && old.indexOf(this) > -1)
						old.remove(this);
					else if (old._indexOf && old._indexOf(this) > -1)
						old._remove(this);

				} catch (ex) {

					// ignore this error.
				}
			}

			// register with the new parent
			if (value) {

				if (!wisej.web.DesignMode)
					this.core.registerComponent(this, value);

				// update the appearance key.
				this._setChildAppearance(value);

				if (value.add) {
					value.add(this);
				}
				else {
					value._add(this);
				}

				// update the user bounds in case this control
				// is being parented by a control with a layout
				// that cannot handle non-user bounds.
				this.__updateUserBounds();
			}

			// fire the "parentChanged" event.
			this.fireDataEvent("changeParent", { newParent: value, oldParent: old });
		},

		/**
		* Applies the state events property.
		*
		* Attach a listener for the state events that
		* marks the component as dirty.
		*/
		_applyStateEvents: function (value, old) {

			// detach old listeners not listed in the new list
			if (old != null && old.length > 0) {
				for (var i = 0; i < old.length; i++) {
					this.removeListener(old[i], this._stateEventHandler, this);
				}
			}

			// attach the property change listener to the state properties
			if (value != null && value.length > 0) {
				for (var i = 0; i < value.length; i++) {
					this.addListener(value[i], this._stateEventHandler, this);
				}
			}
		},

		/**
		 * _stateEventHandler
		 *
		 * Listens to state events and marks the component as dirty.
		 */
		_stateEventHandler: function (e) {

			this.setDirty(true);
		},

		/**
		 * If the widget is in design mode, this handler
		 * fires the "render" event, which is used by the designer
		 * to know that the widget is ready to be scraped.
		 *
		 * If the widget implements a method _onDesignRender it calls it and it's
		 * now the widget's responsibility to fire "render".
		 *
		 * If the widget is NOT in design mode, this handler
		 * enables the firing of state and all other events.
		 */
		__onDesignRender: function (e) {

			if (wisej.web.DesignMode) {

				if (this._onDesignRender)
					this._onDesignRender();
				else
					this.fireEvent("render");
			}
		},
	}

});


/**
 * wisej.mixin.MWisejMenu
 * 
 * All Wisej menu classes must include this mixin to be recognized
 * by the Wisej.Core implementation.
 */
qx.Mixin.define("wisej.mixin.MWisejMenu", {

	include: [wisej.mixin.MWisejComponent],

	/**
	 * construct
	 */
	construct: function () {
	},

	properties: {

		/**
		 * Collection of child menu items.
		 *
		 * The collection always contains an array of widgets.
		 * 
		 * The incoming value can be:
		 *
		 *		- Array of widget instances.  
		 *		- Array of IDS. In which case all the widgets must have been created already.
		 *		- Array of widget definitions, that is the JSON definition of the widgets.
		 */
		menuItems: { init: [], apply: "_applyMenuItems", transform: "_transformMenuItems" },

		/**
		 * Parent property.
		 *
		 * This is the parent of the menu item.
		 */
		parent: { init: null, nullable: true, apply: "_applyParent", transform: "_transformComponent" },

		/**
		 * Container property.
		 *
		 * Identifies the container widget that is using this menu element.
		 */
		container: {init: null, nullable: true, check:"String"},

		/**
		 * Index property.
		 *
		 * This is the index (position) the this menu item in the parent collection of items.
		 */
		index: { init: -1, check: "Integer", apply: "_applyIndex" },

		/**
		 * Mnemonic property.
		 *
		 * Registers the mnemonic character as a shortcut to the execute function on this widget.
		 * The character is register as a Alt+[character] command.
		 */
		mnemonic: { check: "String", apply: "_applyMnemonic", event: "changeMnemonic" },

		/**
		 * Shortcut property.
		 *
		 * Enables the shortcut for the menu item.
		 */
		shortcut: { check: "String", apply: "_applyShortcut", event: "changeShortcut" },

		/**
		 * Accessibility property.
		 *
		 * Sets the combination  of accessibility attributes on the current element:
		 *
		 *    name = the name attributes.
		 *    description = the alt attribute.
		 *    role = the role attribute.
		 */
		accessibility: { init: null, check: "Map", apply: "_applyAccessibility" },
	},

	statics: {

		// the delayed targets for shortcut handling.
		__shortcutTargets: null,

		// the delayed targets for mnemonic handling.
		__mnemonicTargets: null,

	},

	members: {

		/**
		 * Wisej marker.
		 */
		isWisejMenu: true,

		// reference to the mnemonic accelerator handler.
		__mnemonicAccel: null,

		// reference to the shortcut accelerator handler.
		__shortcutAccel: null,

		/**
		 * Transforms the incoming collection of child widgets
		 * by converting the widget id to the widget instance.
		 */
		_transformMenuItems: function (value) {

			if (value == null || value.length == 0)
				return value;

			// list of json definitions?
			if (typeof value[0] !== "string") {

				// collection of widgets?
				if (value[0] instanceof qx.ui.core.Widget) {

					value = value;

				}
				else {
					var widgets = [];

					// create the widgets from the config data.
					for (var i = 0; i < value.length; i++) {

						var widget = null;
						var config = value[i];

						if (wisej.web.DesignMode)
							widget = this._createDesignTimeComponent(config);
						else
							widget = this.core.createComponent(config);

						if (widget)
							widgets.push(widget);
					}
					value = widgets;
				}
			}
			else {

				var widgets = [];

				if (!wisej.web.DesignMode) {
					// resolve the widget from the IDs.
					for (var i = 0; i < value.length; i++) {

						var widget = this.core.getComponent(value[i]);

						if (widget)
							widgets.push(widget);
					}
				}

				value = widgets;
			}

			return value;
		},

		/**
		 * Applies the parent property.
		 */
		_applyParent: function (value, old) {

			// remove from the previous owner/parent.
			if (old != null) {

				// menu items must have a menu as their parent.
				var menu = old;
				if (menu.getMenu)
					menu = menu.getMenu();

				if (menu != null)
					menu.remove(this);
			}

			if (value != null) {

				// menu items must have a menu as their parent.
				var menu = value;
				if (menu.getMenu)
					menu = menu.getMenu();

				// create the child popup menu.
				if (menu == null) {
					menu = new qx.ui.menu.Menu();

					// fire the popup event when the child menu appears.
					var parent = value;
					menu.addListener("appear", function (e) {
						parent.fireEvent("popup");
					}, this);

					value.setMenu(menu);
				}

				// update the appearance key.
				this._setChildAppearance(menu);

				var index = this.getIndex();
				if (index < 0)
					menu.add(this);
				else
					menu.addAt(this, index);
			}
		},

		/**
		 * Applies the index property.
		 *
		 * The index in the parent collection is changed only if the item
		 * already has a parent, otherwise the index is set in _applyParent.
		 */
		_applyIndex: function (value, old) {

			var parent = this.getParent();
			if (parent == null)
				return;

			if (parent.indexOf(this) == value)
				return;

			parent.addAt(this, value);
		},

		/**
		 * Applies the shortcut property.
		 */
		_applyShortcut: function (value, old) {

			if (!value && old) {
				this._disposeObjects("__shortcutAccel");
			}

			if (value) {
				if (!this.__shortcutAccel) {
					this.__shortcutAccel = new qx.bom.Shortcut(null);
					this.__shortcutAccel.addListener("execute", this.__onShortcut, this);
				}

				this.__shortcutAccel.setShortcut(value);
			}
		},

		/**
		 * Applies the mnemonic property.
		 *
		 * Registers a command for the Alt+[mnemonic] shortcut.
		 */
		_applyMnemonic: function (value, old) {

			if (!value && old) {
				this.removeState("mnemonic");
				this._disposeObjects("__mnemonicAccel");
			}

			if (value) {
				if (!this.__mnemonicAccel) {
					this.addState("mnemonic");
					this.__mnemonicAccel = new qx.bom.Shortcut(null);
					this.__mnemonicAccel.addListener("execute", this.__onMnemonic, this);
				}

				this.__mnemonicAccel.setShortcut("Alt+" + value);

			}
		},

		__onShortcut: function (e) {

			// ignore shortcuts on menu items on menu bars that are not
			// in an active top-level container: page, form, or desktop.
			var container = this.findContainer();
			if (container && !wisej.utils.Widget.canExecute(container))
				return;

			// since we can have multiple shortcuts we need to process all of them to determine
			// the target control on which to call execute.
			var list = wisej.mixin.MWisejMenu.__shortcutTargets;
			if (list == null) {
				list = wisej.mixin.MWisejMenu.__shortcutTargets = [];

				var me = this;
				setTimeout(function () {
					me.__executeShortcut();
				}, 1);
			}
			list.push(this);
		},

		__onMnemonic: function (e) {

			// ignore mnemonics on menu items on menu bars that are not
			// in an active top-level container: page, form, or desktop.
			var container = this.findContainer();
			if (container && !wisej.utils.Widget.canExecute(container))
				return;

			// since we can have multiple mnemonics we need to process all of them to determine
			// the target menu item on which to call execute only once.
			var list = wisej.mixin.MWisejMenu.__mnemonicTargets;
			if (list == null) {
				list = wisej.mixin.MWisejMenu.__mnemonicTargets = [];

				var me = this;
				setTimeout(function () {
					me.__executeMnemonic();
				}, 1);
			}
			list.push(this);
		},

		__executeShortcut: function () {

			var list = wisej.mixin.MWisejMenu.__shortcutTargets;
			if (list != null && list.length > 0) {

				// iterate all the targets and stop executing as soon as a target
				// returns true.
				for (var i = 0; i < list.length; i++) {
					var target = list[i];
					if (target.executeShortcut) {
						if (target.executeShortcut(list, i))
							break;
					}
				}
			}
			wisej.mixin.MWisejMenu.__shortcutTargets = null;
		},

		__executeMnemonic: function () {

			var list = wisej.mixin.MWisejMenu.__mnemonicTargets;
			if (list != null && list.length > 0) {

				// iterate all the targets and stop executing as soon as a target
				// returns true.
				for (var i = 0; i < list.length; i++) {
					var target = list[i];
					if (target.executeMnemonic) {
						if (target.executeMnemonic(list, i))
							break;
					}
				}
			}

			wisej.mixin.MWisejMenu.__mnemonicTargets = null;
		},

		/**
		 * Applies the menuItems property.
		 */
		_applyMenuItems: function (value, old) {

			// remove all child items.
			var menu = this;
			if (this.getMenu)
				menu = this.getMenu();

			if (menu)
				menu.removeAll();

			if (value && value.length > 0) {

				// add the menu items to the menu container.
				for (var i = 0; i < value.length; i++) {

					var menuItem = value[i];
					menuItem.setParent(this);
				}
			}
		},

		/**
		 * Finds the widget that owns this menu item.
		 */
		findContainer: function () {

			var container = this.core.getComponent(this.getContainer());

			if (container == null) {
				for (var parent = this.getParent() ; parent != null; parent = parent.getParent()) {
					if (parent.getParent() == null) {
						container = parent;
						break;
					}
				}
			}

			return container;
		},

		/**
		 * Applies the accessibility attributes.
		 */
		_applyAccessibility: function (value, old) {

			var el = this.getAccessibilityElement();
			if (el) {

				if (value) {
					el.setAttributes({
						name: value.name,
						alt: value.description,
						role: value.role.toLowerCase()
					});
				}
				else {
					el.setAttributes({
						alt: null,
						name: null,
						role: null,
					});
				}
			}
		},
	},

	destruct: function () {

		this._disposeObjects("__shortcutAccel");
		this._disposeObjects("__mnemonicAccel");
	}

});


/**
 * wisej.mixin.MShortcutTarget
 * 
 * Adds support for shortcut and mnemonic handling.
 */
qx.Mixin.define("wisej.mixin.MShortcutTarget", {

	properties: {

		/**
		 * Mnemonic property.
		 *
		 * Registers the mnemonic character as a shortcut to the execute function on this widget.
		 * The character is register as a Alt+[character] command.
		 */
		mnemonic: { check: "String", apply: "_applyMnemonic", event: "changeMnemonic" },

		/**
		 * Shortcut property.
		 *
		 * Registers the shortcut to the execute function on this widget.
		 */
		shortcut: { check: "String", apply: "_applyShortcut", event: "changeShortcut" },

	},

	statics: {

		// the delayed target for shortcut handling.
		__shortcutTargets: null,

		// the delayed target for mnemonic handling.
		__mnemonicTargets: null,

	},

	members: {

		// reference to the shortcut.
		__shortcutAccel: null,

		// reference to the mnemonic.
		__mnemonicAccel: null,

		/**
		 * Applies the shortcut property.
		 *
		 * Registers an accelerator for the shortcut.
		 */
		_applyShortcut: function (value, old) {

			if (!value && old) {
				this._disposeObjects("__shortcutAccel");
			}

			if (value) {

				if (!this.__shortcutAccel) {
					this.__shortcutAccel = new qx.bom.Shortcut(null);
					this.__shortcutAccel.addListener("execute", this.__onShortcut, this);
				}

				this.__shortcutAccel.setShortcut(value);
			}
		},

		/**
		 * Applies the mnemonic property.
		 *
		 * Registers an accelerator for the Alt+[mnemonic].
		 */
		_applyMnemonic: function (value, old) {

			if (!value && old) {
				this.removeState("mnemonic");
				this._disposeObjects("__mnemonicAccel");
			}

			if (value) {

				if (!this.__mnemonicAccel) {
					this.addState("mnemonic");
					this.__mnemonicAccel = new qx.bom.Shortcut(null);
					this.__mnemonicAccel.addListener("execute", this.__onMnemonic, this);
				}

				this.__mnemonicAccel.setShortcut("Alt+" + value);
			}
		},

		__onShortcut: function (e) {

			// ignore shortcuts on widgets that are not
			// in an active top-level container: page, form, or desktop.
			if (!wisej.utils.Widget.canExecute(this))
				return;

			// since we can have multiple shortcuts we need to process all of them to determine
			// the target control on which to call execute.
			var list = wisej.mixin.MShortcutTarget.__shortcutTargets;
			if (list == null) {
				list = wisej.mixin.MShortcutTarget.__shortcutTargets = [];

				var me = this;
				setTimeout(function () {
					me.__executeShortcut();
				}, 1);
			}
			list.unshift(this);
		},

		__onMnemonic: function (e) {

			// ignore mnemonics on widgets that are not
			// in an active top-level container: page, form, or desktop.
			if (!wisej.utils.Widget.canExecute(this))
				return;

			// since we can have multiple shortcuts we need to process all of them to determine
			// the target control on which to call execute.
			var list = wisej.mixin.MShortcutTarget.__mnemonicTargets;
			if (list == null) {
				list = wisej.mixin.MShortcutTarget.__mnemonicTargets = [];

				var me = this;
				setTimeout(function () {
					me.__executeMnemonic();
				}, 1);
			}
			list.unshift(this);
		},

		__executeShortcut: function () {

			var list = wisej.mixin.MShortcutTarget.__shortcutTargets;
			if (list != null && list.length > 0) {

				// iterate all the targets and stop executing as soon as a target
				// returns true.
				for (var i = 0; i < list.length; i++) {
					var target = list[i];
					if (target.executeShortcut) {
						if (target.executeShortcut(list, i))
							break;
					}
				}
			}
			wisej.mixin.MShortcutTarget.__shortcutTargets = null;
		},

		__executeMnemonic: function () {

			var list = wisej.mixin.MShortcutTarget.__mnemonicTargets;
			if (list != null && list.length > 0) {

				// iterate all the targets and stop executing as soon as a target
				// returns true.
				for (var i = 0; i < list.length; i++) {
					var target = list[i];
					if (target.executeMnemonic) {
						if (target.executeMnemonic(list, i))
							break;
					}
				}
			}
			wisej.mixin.MShortcutTarget.__mnemonicTargets = null;
		}
	},

	destruct: function () {

		this._disposeObjects("__shortcutAccel");
		this._disposeObjects("__mnemonicAccel");
	}

});


/**
 * wisej.mixin.MBorderStyle
 * 
 * Adds support for the BorderStyle property.
 */
qx.Mixin.define("wisej.mixin.MBorderStyle", {

	properties: {

		/**
		 * BorderStyle property.
		 */
		borderStyle: { init: "none", check: ["none", "solid", "dashed", "dotted", "double"], apply: "_applyBorderStyle" },

	},

	members: {

		/**
		 * Applies the borderStyle property.
		 *
		 * The borderStyles is applied as a state to be able to
		 * theme the styles.
		 */
		_applyBorderStyle: function (value, old) {

			this.removeState("borderNone");
			this.removeState("borderSolid");
			this.removeState("borderDashed");
			this.removeState("borderDotted");
			this.removeState("borderDouble");

			if (value)
				this.addState("border" + qx.lang.String.firstUp(value));
		},

	}

});


/**
 * wisej.mixin.MAccelerators
 * 
 * Adds support for the Accelerators property.
 */
qx.Mixin.define("wisej.mixin.MAccelerators", {

	/**
	 * destruct
	 * 
	 * - Removes the widget from our global registry.
	 * - Unregisters the widget from its container.
	 */
	destruct: function () {

		if (wisej.web.DesignMode)
			return;

		// unregister the accelerator listener.
		if (this.__accelerators) {
			qx.event.Registration.removeListener(document.body, "keydown", this.__onAccelerator, this);
		}
	},

	properties: {

		/**
		 * Accelerators property.
		 *
		 * Defines a list of keys that fire the "accelerator" event when pressed regardless of the focus.
		 */
		accelerators: { check: "Array", apply: "_applyAccelerators" },

	},

	statics: {

		/** List of keys that should not go to the browser when they are used as accelerator. */
		__preventDefaultKeys: ["F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14"]

	},

	members: {

		/** accelerators map. */
		__accelerators: null,

		/**
		 * Applies the accelerators property.
		 */
		_applyAccelerators: function (value, old) {

			// unregister the previous commands.
			if (old != null && old.length > 0 && this.__accelerators) {

				for (var i = 0; i < old.length; i++) {

					var key = this.__translateAcceleratorKey(old[i]);

					if (value && value.indexOf(key) > -1)
						continue;

					delete this.__accelerators[key];
				}

				if (qx.lang.Object.isEmpty(this.__accelerators) && (value == null || value.length == 0)) {
					this.__accelerators = null;
					qx.event.Registration.removeListener(document.body, "keydown", this.__onAccelerator, this, true);
				}
			}

			// register the new accelerators.
			if (value != null && value.length > 0) {

				// register to receive global keydown events the fist time we have an accelerator.
				if (this.__accelerators == null) {
					this.__accelerators = {};
					qx.event.Registration.addListener(document.body, "keydown", this.__onAccelerator, this, true);
				}

				for (var i = 0; i < value.length; i++) {
					var key = this.__translateAcceleratorKey(value[i]);
					this.__accelerators[key] = true;
				}
			}
		},

		__translateAcceleratorKey: function (code) {

			code = qx.lang.String.firstUp(code);
			switch (code) {
				case "Esc": code = "Escape"; break;
				case "Return": code = "Enter"; break;
				case "PageUp": code = "PgUp"; break;
				case "PageDown": code = "PgDn"; break;
				case "PrintScreen": code = "Print"; break;
			}

			return code;
		},

		__onAccelerator: function (e) {

			if (this.__accelerators) {

				// find the target of the keypress event,
				var target = wisej.utils.Widget.findWisejComponent(e.getTarget());

				// process only accelerator keys from child widgets.
				if (this != target
					&& this instanceof qx.ui.core.Widget
					&& !qx.ui.core.Widget.contains(this, target)) {

					return;
				}

				var id = target.isWisejComponent ? target.getId() : null;

				var code = (e.getModifiers() << 16) | e.getKeyCode();
				if (this.__accelerators[code]) {

					this.fireDataEvent("accelerator", { code: code, target: id });

					// prevent default for Ctrl accelerators to prevent the browser's default actions.
					if (e.getModifiers() == qx.event.type.Dom.CTRL_MASK)
						e.preventDefault();
				}
				else {
					var key = e.getKeyIdentifier();
					if (this.__accelerators[key]) {

						this.fireDataEvent("accelerator", { code: code, target: id });

						// prevent default for browser keys or we get the search box on F3
						// and the tools on F12, etc...
						if (key.length > 1 && key[0] == "F")
							e.preventDefault();
					}
				}
			}
		},
	},
});
