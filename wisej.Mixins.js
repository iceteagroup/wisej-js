///////////////////////////////////////////////////////////////////////////////
//
// (C) 2015 ICE TEA GROUP LLC - ALL RIGHTS RESERVED
//
// 
//
// ALL INFORMATION CONTAINED HEREIN IS, AND REMAINS
// THE PROPERTY OF ICE TEA GROUP LLC AND ITS SUPPLIERS, IF ANY.
// THE INTELLECTUAL PROPERTY AND TECHNICAL CONCEPTS CONTAINED
// HEREIN ARE PROPRIETARY TO ICE TEA GROUP LLC AND ITS SUPPLIERS
// AND MAY BE COVERED BY U.S. AND FOREIGN PATENTS, PATENT IN PROCESS, AND
// ARE PROTECTED BY TRADE SECRET OR COPYRIGHT LAW.
//
// DISSEMINATION OF THIS INFORMATION OR REPRODUCTION OF THIS MATERIAL
// IS STRICTLY FORBIDDEN UNLESS PRIOR WRITTEN PERMISSION IS OBTAINED
// FROM ICE TEA GROUP LLC.
//
///////////////////////////////////////////////////////////////////////////////


/**
 * wisej.mixin.MWisejComponent
 * 
 * All Wisej components must include this mixin to be recognized
 * by the Wisej.Core implementation.
 */
qx.Mixin.define("wisej.mixin.MWisejComponent", {

	/**
	 * construct
	 *
	 * Initializes the core reference to Wisej.Core.
	 */
	construct: function () {

		if (wisej.web.DesignMode) {
			this.core = {
				processingActions: false
			};
		}
		else {

			this.core = Wisej.Core;

			// set the "owner" and "container" attributes for QA automation.
			this.addListener("changeMenuVisibility", function (e) {
				var menu = e.getData();
				if (menu.isVisible()) {
					wisej.utils.Widget.setAutomationAttributes(menu, this);
				}
			});

			// when "automation.mode" is enabled, change the id of the element on creation.
			if (this instanceof qx.ui.core.Widget
				&& qx.core.Environment.get("automation.mode") === true) {

				this.addListenerOnce("appear", function (e) {
					wisej.utils.Widget.setAutomationID(e.getTarget());
				}, this);
			}
		}
	},

	/**
	 * destruct
	 * 
	 * - Removes the widget from our global registry.
	 * - Unregisters the widget from its container.
	 */
	destruct: function () {

		if (wisej.web.DesignMode) {

			if (wisej.web.DesignComponents)
				delete wisej.web.DesignComponents[this.getId()];

			return;
		}

		// unregister if not a control, otherwise
		// we call unregisterComponent twice.
		if (!this.isWisejControl)
			this.core.unregisterComponent(this);
	},

	statics: {

		/**
		 * Interval in ms between a click and double click.
		 */
		DBLCLICK_INTERVAL: 350
	},

	properties: {

		/**
		 * The unique id of the widget, generated by the server.
		 */
		id: { init: null, check: "String", apply: "_applyId" },

		/**
		 * The name of the control set by the server.
		 * 
		 * This is a unique name within the container. It is also
		 * used to register a reference to the control in the container:
		 * 
		 *	i.e.: App.Window1.button1;
		 */
		name: { init: "", check: "String", apply: "_applyName", event: "changeName" },

		/**
		 * List of event descriptors defined by the server.
		 * 
		 * The events can be defined simply by the name and an optional argument name that
		 * will contain a data object with data related to the event.
		 * 
		 *		config.events = ["click", "tabactivated(NewTab)"];
		 */
		wiredEvents: { init: null, check: "Array", nullable: true, apply: "_applyWiredEvents", event: "changeWiredEvents" }
	},

	members: {

		/**
		 * Wisej marker.
		 */
		isWisejComponent: true,

		/**
		 * Wisej.Core reference.
		 */
		core: null,

		/**
		 * getTopLevelContainer
		 *
		 * Returns the container for this widget. It's either:
		 *
		 *  - MainPage
		 *  - Desktop
		 *  - Form
		 *  - MdiChild
		 */
		getTopLevelContainer: function () {

			if (this.isWisejControl && this.isTopLevel())
				return this;

			if (this instanceof qx.ui.core.Widget) {
				var parent = this.getLayoutParent();
				while (parent) {

					if (parent.isWisejControl) {

						// stop at the first mdi child form.
						if (parent instanceof wisej.web.Form && parent.isMdiChild())
							break;

						// stop at the first top level widget: Form, Page, Desktop
						if (parent.isTopLevel())
							break;
					}

					parent = parent.getLayoutParent();
				}

				return parent;
			}

			return null;
		},

		/**
		 * Converts a widget string id to a widget reference.
		 */
		_transformComponent: function (value) {

			if (value == null)
				return null;

			var component = null;
			if (typeof value !== "string") {

				// the value is already a widget?
				if (value instanceof qx.core.Object) {

					component = value;

				} else {

					// create the widgets from the configuration.
					var config = value;
					if (wisej.web.DesignMode) {

						component = this._createDesignTimeComponent(config);
					}
					else {

						// check if the configuration specifies an id and if
						// the component already exists, if it does, retrieve it and update it.
						var id = config.id;
						if (id)
							component = this.core.getComponent(id);

						// already exist? update it.
						if (component) {
							delete config.id;
							delete config.className;
							if (component.isWisejControl)
								component.setState(config);
							else
								component.set(config);
						}
						else {
							// otherwise create it.
							component = this.core.createComponent(config);
						}
					}
				}
			}
			else {

				// retrieve the widgets using the id.
				if (!wisej.web.DesignMode) {
					var id = value;
					component = this.core.getComponent(id);
				}
				else {

					// when in design mode, use the DesignComponents map.
					if (wisej.web.DesignComponents) {
						var id = value;
						component = wisej.web.DesignComponents[id];
					}
				}

			}

			return component;
		},

		/**
		 * Transforms the incoming collection of child widgets
		 * by converting the widget id to the widget instance.
		 */
		_transformComponents: function (value) {

			if (value == null || value.length == 0)
				return [];

			// list of json definitions?
			if (typeof value[0] !== "string") {

				// collection of widgets?
				if (value[0] instanceof qx.core.Object) {

					value = value;

				} else {

					// create the widgets from the config data.
					var widgets = [];
					for (var i = 0; i < value.length; i++) {

						var widget = null;
						var config = value[i];

						if (config && config.className) {
							if (wisej.web.DesignMode)
								widget = this._createDesignTimeComponent(config);
							else
								widget = this.core.createComponent(config);

							if (widget)
								widgets.push(widget);
						}

					}
					value = widgets;
				}
			}
			else {

				var widgets = [];

				if (!wisej.web.DesignMode) {

					// resolve the widget from the IDs.
					for (var i = 0; i < value.length; i++) {
						var widget = this.core.getComponent(value[i]);
						if (widget)
							widgets.push(widget);
					}
				}
				else {
					// when in design mode, use the DesignComponents map.
					if (wisej.web.DesignComponents) {
						for (var i = 0; i < value.length; i++) {
							var widget = wisej.web.DesignComponents[value[i]];
							if (widget)
								widgets.push(widget);
						}
					}
				}

				value = widgets;
			}

			return value;
		},

		/**
		 * Converts the menu id to a menu instance.
		 */
		_transformMenu: function (value) {

			if (typeof value === "string") {
				if (wisej.web.DesignMode) {
					value = null;
				}
				else {
					var id = value;
					value = this.core.getComponent(id);
				}
			}

			return value;
		},

		/**
		 * Makes the child component act as a subcomponent when the 
		 * appearance key is defined as "$parent/[child key]".
		 */
		_setChildAppearance: function (parent) {

			var key = this.getAppearance();

			if (key && key.indexOf("$parent/") === 0) {
				key = key.substr("$parent/".length);
				this.$$subcontrol = key;
				this.$$subparent = parent;
				this.syncAppearance();
			}
		},

		/**
		 * Applies the name property.
		 *
		 * Sets the name of the component in the dom.
		 */
		_applyName: function (value, old) {

			var el1 = this.getAccessibilityElement();
			if (el1) {
				if (value)
					el1.setAttribute("name", value, true);
				else
					el1.removeAttribute("name", true);
			}

			if (el1 && this instanceof qx.ui.core.Widget) {
				var el2 = this.getContentElement();
				if (el1 !== el2) {
					if (value)
						el2.setAttribute("name", value, true);
					else
						el2.removeAttribute("name", true);
				}
			}
		},

		// returns the element to use to set automation attributes.
		getAutomationElement: function () {

			if (this.getAutomationTarget) {
				var target = this.getAutomationTarget();
				if (target)
					return target.getContentElement();
			}

			return (this instanceof qx.ui.core.Widget) ? this.getContentElement() : null;
		},

		// returns the element to use to set accessibility attributes.
		getAccessibilityElement: function () {

			if (this.getAccessibilityTarget) {
				var target = this.getAccessibilityTarget();
				if (target)
					return target.getContentElement();
			}

			return (this instanceof qx.ui.core.Widget) ? this.getContentElement() : null;
		},

		/**
		 * Applies the id property.
		 * 
		 * Registers this widget in the global registry using
		 * the unique id as the key.
		 */
		_applyId: function (value, old) {

			if (this.isWisejControl) {

				var el = this.getContentElement();
				if (el)
					el.setAttribute("id", value);
			}

			if (value && !wisej.web.DesignMode)
				this.core.registerComponent(this);
		},

		/**
		 * The collection of wired event descriptors.
		 */
		__wiredEvents: null,

		/**
		* Applies the wired events property.
		* 
		* Parses the event descriptors and hook
		* an event handler for each event.
		* 
		* The event handler normalizes the event arguments
		* and passes them to Wisej.Core to send them back to
		* the server.
		*/
		_applyWiredEvents: function (value, old) {

			if (wisej.web.DesignMode)
				return;

			// ensure the collection of event handlers.
			this.__wiredEvents = this.__wiredEvents || {};

			// parse the descriptors
			var oldDescriptors = this.core.parseEventDescriptors(old);
			var newDescriptors = this.core.parseEventDescriptors(value);

			// detach previously attached event handlers
			var events = old;
			if (oldDescriptors != null) {

				for (var type in oldDescriptors) {

					// don't remove the old events  that are still in
					// the new list of wired events.
					if (newDescriptors && newDescriptors[type]) {
						delete newDescriptors[type];
						continue;
					}

					try {

						// remove the event handler.
						var handler = this.__wiredEvents[type];
						if (handler) {
							delete this.__wiredEvents[type];
							this.removeListener(type, handler, this);
						}
					}
					catch (error) {

						if (this.core)
							this.core.logError(error);
					}
				}
			}

			//
			// handler closure.
			//
			function makeHandler(descriptor) {

				// argument value converters.
				function convertData(data) {

					if (data == null)
						return;

					// wisej control? return the id.
					if (data.isWisejComponent)
						return data.getId();

					// primitive?
					if ((data instanceof String || data instanceof Date || data instanceof Boolean)
						|| ("string,number,boolean".indexOf(typeof data) > -1))
						return data;

					// array or map?
					if (data instanceof Array) {
						var array = null;
						for (var i = 0; i < data.length; i++) {
							var value = convertData(data[i]);
							if (value != null) {
								if (array == null)
									array = new Array();

								array.push(value);
							}
						}

						return array;
					}
					else {

						// don't serialize complex QX objects.
						if (data.classname && qx.Class.isDefined(data.classname))
							return null;

						var map = null;
						for (var name in data) {
							var value = convertData(data[name]);
							if (value != null) {
								if (map == null)
									map = {};

								map[name] = value;
							}
						}

						return map;
					}
				}

				// determined whether the event will generate a dblclick.
				function isDoubleClick(e) {

					var type = e.getType();
					switch (type) {
						case "tap":
						case "click":
						case "tagClick":
						case "gridCellTap":
							{
								if (lastEvent.name === type
									&& lastEvent.target === e.getTarget().$$hash
									&& Date.now() - lastEvent.timestamp < wisej.mixin.MWisejComponent.DBLCLICK_INTERVAL) {
									return true;
								}

								lastEvent.name = type;
								lastEvent.timestamp = Date.now();
								lastEvent.target = e.getTarget().$$hash;
							}
							break;
					}

					return false;
				}

				// keeps track of the last click event to filter out duplicate clicks on dblclicks.
				var lastEvent = {
					name: "",
					target: null,
					timestamp: 0
				};

				//
				// event handler.
				//
				function handler(e) {

					var target = this;
					var type = e.getType();

					// don't route any event back to the server
					// while the component is in the middle of updating its state.
					if (this.__inSetState)
						return;

					// find the original wisej target for the event.
					var originalTarget = wisej.utils.Widget.findWisejComponent(e.getOriginalTarget());

					// dispatch bubbled events only to the actual target and not the bubbled up target, otherwise
					// a parent control will get the events on the child controls.
					if (originalTarget && originalTarget !== target) {

						// these are the events that cannot fire when bubbled. others, like "drop", can.
						switch (type) {

							case "keyup":
							case "keydown":
							case "keypress":
							case "focusin":
							case "focusout":

								// if the event bubbled because the target is disabled
								// or an inner widget (i.e. a cell editor, a component of a larger widget), let it be processed by the current target.
								if (!originalTarget.isEnabled() || originalTarget.hasState("inner")) {

									if (type !== "keypress" && type !== "keydown" && type !== "keyup") {
										e.stopPropagation();
									}

									// route the bubbled event.
									break;
								}

								// don't route the event.
								return;

							case "tap":
							case "dbltap":
							case "click":
							case "dblclick":
							case "mouseout":
							case "mouseover":
							case "mouseup":
							case "mousedown":
							case "mousemove":
							case "mousewheel":

								// if the event bubbled because the original target is disabled, anonymous 
								// or an inner widget (i.e. a cell editor, a component of a larger widget), let it be processed by the current target.
								if (!originalTarget.isEnabled() || originalTarget.isAnonymous() || originalTarget.hasState("inner")) {

									e.stopPropagation();

									// route the bubbled event.
									break;
								}

								// don't route the event.
								return;
						}
					}

					// stop "keypress: when keyCode is a not a printable character.
					if (e instanceof qx.event.type.KeySequence
						&& type === "keypress"
						&& wisej.utils.Widget.isInputKey(e.getKeyIdentifier())) {
						return;
					}

					// stop duplicate click events when it's a double click
					if (isDoubleClick(e))
						return;

					// normalize the event args
					// and assign them to the corresponding argument name.
					var args = null;

					if (descriptor.argNames.length > 0) {
						var data = e.getData ? e.getData() : null;
						var value = convertData(data);
						args = args || {};
						args[descriptor.argNames[0]] = value;
					}

					// add standard arguments
					if (e.getButton) {
						var button = 0;
						switch (e.getButton()) {
							case "right": button = 2; break;
							case "middle": button = 1; break;
						}
						args = args || {};
						args.button = button;
						args.modifiers = e.getModifiers();
						args.lockState = e.getKeyLockState();
					}
					else if (window.event) {
						var event = window.event;
						if (event.button !== undefined) {
							args = args || {};
							args.button = event.button | 0;
						}
					}

					if (e.getDocumentTop) {
						args = args || {};
						args.y = e.getDocumentTop() | 0;
						args.x = e.getDocumentLeft() | 0;
					}
					else if (window.event) {
						var event = window.event;
						if (event.pageX !== undefined) {
							args = args || {};
							args.y = event.pageY | 0;
							args.x = event.pageX | 0;
						}
					}

					// detect the keyboard
					if (e.getKeyCode) {
						args = args || {};
						args.keyCode = e.getKeyCode();
						args.key = e.getKeyIdentifier();
						args.modifiers = e.getModifiers();
						args.lockState = e.getKeyLockState();
					}
					else if (window.event) {
						var event = window.event;
						if (event.shiftKey !== undefined) {
							args = args || {};
							if (event.key !== undefined)
								args.key = event.key.toUpperCase();
							if (event.keyCode !== undefined || event.charCode !== undefined)
								args.keyCode = event.keyCode || event.charCode;
							args.modifiers =
								event.shiftKey ? 1 : 0
								| event.ctrlKey ? 2 : 0
									| event.altKey ? 4 : 0
										| event.metaKey ? 8 : 0;
						}
					}

					// mouse wheel.
					if (e.getWheelDelta) {
						args = args || {};
						args.wheelDelta = e.getWheelDelta() | 0;
					}

					// add the original target, if any.
					if (originalTarget != null && originalTarget !== target) {
						args = args || {};
						args.originalId = originalTarget.getId();
					}

					// detect the role of the element that caused the event.
					if (e.getNativeEvent) {
						var role = wisej.utils.Widget.getTargetRole(e);
						if (role) {
							args = args || {};
							args.role = role;
						}
					}

					// add custom event data.
					// used to pass information about the a drag drop target
					// but it can be used for other purposed.
					var eventData = e.getUserData("eventData");
					if (eventData != null) {
						args = args || {};
						args.eventData = eventData;
						e.setUserData("eventData", null);
					}

					var id = target.getId();
					if (!id && target.hasState("inner")) {
						target = wisej.utils.Widget.findWisejComponent(target, true /* exclude inner */);
						if (target)
							id = target.getId();
					}

					if (id)
						this.core.fireEvent(id, descriptor.type, args, target);
				}
				return handler;
			}
			// ----------------------------------

			// attach the new event handlers.
			if (newDescriptors != null) {

				for (var type in newDescriptors) {

					var descr = newDescriptors[type];

					// attach the handler closure to the event
					var handler = makeHandler(descr);
					this.addListener(type, handler, this);
					this.__wiredEvents[type] = handler;
				}
			}
		},

		/**
		 * Checks if the event is wired to the server.
		 */
		isWired: function (type) {

			return this.__wiredEvents && this.__wiredEvents[type];
		},

		/**
		 * Destroys all the child controls.
		 *
		 * @param state {Object} optional container. If not specified, "this" is the container.
		 */
		destroyChildren: function (container) {

			container = container == null ? this : container;

			if (!container.getChildren || !container.remove)
				return;

			// destroy all direct child controls in reverse order.
			var children = container.getChildren().concat();
			for (var i = children.length - 1; i >= 0; i--) {

				var c = children[i];

				// don't destroy child controls.
				if (c.$$subcontrol != null)
					continue;

				container.remove(c);

				if (c.destroy)
					c.destroy();
				else
					c.dispose();
			}
		},

		/**
		 * Creates a design time component.
		 *
		 * @param config {Map} Configuration map to create the component.
		 */
		_createDesignTimeComponent: function (config) {

			if (!config)
				return null;

			// find the widget class
			var className = config.className;

			delete config.root;
			delete config.className;
			delete config.webMethods;

			if (!className)
				throw new Error("Null class name.");

			var widgetClass = qx.Class.getByName(className);
			if (!widgetClass)
				throw new Error("Unknown class name: " + className);

			try {

				// create the QX component.
				var comp = new widgetClass();

				// store in the design-time map.
				wisej.web.DesignComponents = wisej.web.DesignComponents || {};
				wisej.web.DesignComponents[config.id] = comp;

				comp.set(config);
			}
			catch (e) {

				alert(e.message);
			}

			// done
			return comp;
		},

	}
});


/**
 * wisej.mixin.MBackgroundImage
 * 
 * Adds support for multiple background images to the widget.
 */
qx.Mixin.define("wisej.mixin.MBackgroundImage", {

	construct: function () {

		// subclass the syncWidget method.
		this.__syncWidgetBase = this.syncWidget;
		this.syncWidget = this._syncWidget;

		// rightToLeft support.
		this.addListener("changeRtl", function (e) {

			if (e.getData() != e.getOldData())
				this._updateBackgroundImages();

		}, this);
	},

	destruct: function () {

		// remove the css rule associated with this component.
		var stylesheet = wisej.mixin.MBackgroundImage.__stylesheet;
		if (stylesheet && this.__cssRuleSelector) {
			qx.bom.Stylesheet.removeRule(stylesheet, this.__cssRuleSelector);
		}
	},

	properties: {

		/**
		 * Background images to assign to the widget.
		 *
		 * This property can be an array or a single value. It is a map expecting these fields:
		 *
		 *	- image: image source,
		 *	- layout: "none", "tile", "center", "stretch", "zoom", "bestFit", "originalSize",
		 *	- align: "topRight", "middleRight", "bottomRight", "topLeft", "topCenter", "middleLeft", "middleCenter", "bottomLeft", "bottomCenter"
		 *	- size: {width, height}
		 */
		backgroundImages: {
			init: null,
			nullable: true,
			apply: "_applyBackgroundImages",
			transform: "_transformBackgroundImages"
		}
	},

	statics: {

		// the stylesheet used for all background images.
		__stylesheet: null

	},

	members: {

		// saves a reference to the widget's syncWidget method.
		__syncWidgetBase: null,

		// name of the css rule used to set the background image.
		__cssRuleSelector: null,

		/**
		 * Transforms incoming values for the backgroundImage property:
		 *
		 *	- Single values are converted to arrays.
		 */
		_transformBackgroundImages: function (value) {

			if (value) {
				if (!(value instanceof Array))
					value = [value];
			}

			return value;
		},

		/**
		 * Returns the actual list of background images to render.
		 *
		 * Widgets using this mixin have the option to implement
		 * the _getBackgroundImages() method to return a new list of 
		 * images without changing the property backgroundImages.
		 */
		getRealBackgroundImages: function () {

			if (this._getBackgroundImages)
				return this._getBackgroundImages();
			else
				return this.getBackgroundImages();
		},

		/**
		 * Applies the backgroundImage property.
		 */
		_applyBackgroundImages: function (value, old) {

			if (value || old)
				this._updateBackgroundImages();
		},

		_updateBackgroundImages: function () {

			qx.ui.core.queue.Widget.add(this, "updateBackgroundImages");
		},

		_syncWidget: function (jobs) {

			this.__syncWidgetBase(jobs);

			if (!jobs || !jobs["updateBackgroundImages"])
				return;

			this.__updateBackgroundImagesImpl();
		},

		__updateBackgroundImagesImpl: function () {

			var images = this.getRealBackgroundImages();
			var count = images != null ? images.length : 0;
			if (count > 0) {

				var imageUtils = qx.ui.basic.Image;
				var imageLoader = qx.io.ImageLoader;

				// resolve the image aliases and
				// wait for the images to be loaded before updating the control.
				var me = this;
				for (var i = 0; i < images.length; i++) {

					var item = images[i];

					if (item && item.image) {

						// resolves the image URI into a {source, color} map.
						var imageColor = imageUtils.resolveImage(item.image, this.getTextColor());

						if (imageColor.source) {
							item.image = imageColor.source;
							imageLoader.load(item.image, function (url, entry) {

								count--;

								if (entry.loaded) {

									// change the svg image color, if specified either in the image source url or as the widget's text color.
									if (imageColor.color) {
										var svg = imageLoader.getSvg(item.image);
										if (svg) {
											item.image = imageUtils.getSvgDataUri(imageUtils.setSvgColor(svg, imageColor.color));
										}
									}
								}

								// update the css rules once all images have been loaded.
								if (count === 0)
									me.__updateBackgroundCssRule(images);
							});
						}
					}
					else {
						count--;
					}
				}

				// update the css rules once all images have been loaded.
				if (count === 0)
					this.__updateBackgroundCssRule(images);
			}
			else {
				this.__updateBackgroundCssRule(images);
			}
		},

		// updates the css rule linked to this component to 
		// render the background images.
		__updateBackgroundCssRule: function (images) {

			if (images == null) {
				this.__removeBackgroundCssRule();
				return;
			}

			var target = this.__getTarget();
			var styles = this.__buildCssStyles(images);
			var cssRuleAfter = this.__getCssRule(target, "::after");
			if (cssRuleAfter && cssRuleAfter.style) {
				var ruleStyle = cssRuleAfter.style;

				for (var name in styles) {
					ruleStyle[name] = styles[name];
				}

				// update the padding.
				var padding =
					target.getPaddingTop() + "px " +
					target.getPaddingRight() + "px " +
					target.getPaddingBottom() + "px " +
					target.getPaddingLeft() + "px";

				ruleStyle.padding = padding;
			}
		},

		__removeBackgroundCssRule: function () {

			var target = this.__getTarget();
			var el = target.getContentElement();
			if (el)
				el.removeClass(this.__getBackgroundClassName());
		},

		__getTarget: function () {
			var target =
				this._getBackgroundWidget
					? this._getBackgroundWidget()
					: this.getChildControl("pane", true);

			if (target == null)
				target = this;

			return target;
		},

		__getBackgroundClassName: function () {
			return "wisej-background-" + this.$$hash;
		},

		__buildCssStyles: function (images) {

			var style = {
				boxSizing: null,
				backgroundSize: [],
				backgroundImage: [],
				backgroundRepeat: [],
				backgroundOrigin: [],
				backgroundPosition: [],
			};

			if (images && images.length > 0) {

				for (var i = 0; i < images.length; i++) {
					this.__setBackgroundImageStyle(style, images[i]);
				}

				style.backgroundSize = style.backgroundSize.join(",");
				style.backgroundImage = style.backgroundImage.join(",");
				style.backgroundRepeat = style.backgroundRepeat.join(",");
				style.backgroundOrigin = style.backgroundOrigin.join(",");
				style.backgroundPosition = style.backgroundPosition.join(",");
			}
			else {
				style.boxSizing = null;
				style.backgroundSize = null;
				style.backgroundImage = null;
				style.backgroundRepeat = null;
				style.backgroundOrigin = null;
				style.backgroundPosition = null;
			}

			return style;
		},

		__setBackgroundImageStyle: function (styles, image) {

			if (image == null || !image.image)
				return;

			var imageSize;
			if (image.size) {
				if (typeof image.size === "string")
					imageSize = image.size;
				else if (image.size.width && image.size.height)
					imageSize = image.size.width + "px " + image.size.height + "px";
				else if (image.size.width)
					imageSize = image.size.width + "px";
				else if (image.size.height)
					imageSize = image.size.height + "px";
			}
			if (!imageSize) {
				// try to read the background size from the current theme.
				var decorator = qx.theme.manager.Decoration.getInstance().resolve(this.getDecorator());
				if (decorator)
					imageSize = decorator.getStyles().backgroundSize;
			}
			if (!imageSize) {
				imageSize = "auto";
			}

			styles.backgroundImage.push("url(\"" + image.image + "\")");

			if (image.layout && image.layout !== "none") {

				styles.boxSizing = "border-box";
				styles.backgroundOrigin.push("padding-box");

				switch (image.layout) {

					case "tile":
						styles.backgroundSize.push(imageSize);
						styles.backgroundRepeat.push("repeat");
						styles.backgroundPosition.push("left top");
						break;

					case "stretch":
						styles.backgroundSize.push("100% 100%");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push("center");
						break;

					case "center":
						styles.backgroundSize.push(imageSize);
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push("center center");
						break;

					case "zoom":
						styles.backgroundSize.push("cover");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push("center");
						break;

					case "bestFit":
						styles.backgroundSize.push("contain");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push(this.__translateImageAlign(image.align));
						break;

					case "originalSize":
						styles.backgroundSize.push("auto");
						styles.backgroundRepeat.push("no-repeat");
						styles.backgroundPosition.push(this.__translateImageAlign(image.align));
						break;
				}
			}
			else {

				styles.backgroundSize.push(imageSize);

				if (image.align) {

					styles.boxSizing = "border-box";
					styles.backgroundRepeat.push("no-repeat");
					styles.backgroundOrigin.push("content-box");
					styles.backgroundPosition.push(this.__translateImageAlign(image.align));
				}
			}
		},

		__translateImageAlign: function (value) {

			if (!value)
				return "center";

			var left = this.isRtl() ? "right" : "left";
			var right = this.isRtl() ? "left" : "right";

			switch (value) {
				case "topRight": return "top " + right;
				case "middleRight": return "center " + right;
				case "bottomRight": return "bottom " + right;
				case "topLeft": return "top " + left;
				case "topCenter": return "top center";
				case "middleLeft": return "center " + left;
				case "middleCenter": return "center";
				case "bottomLeft": return "bottom " + left;
				case "bottomCenter": return "bottom center";
				default: return "center";
			}
		},

		__getCssRule: function (target, pseudo) {

			var stylesheet = null;

			// create the shared stylesheet.
			var stylesheet = wisej.mixin.MBackgroundImage.__stylesheet;
			if (!stylesheet) {
				stylesheet = qx.bom.Stylesheet.createElement("");
				wisej.mixin.MBackgroundImage.__stylesheet = stylesheet;
			}

			// find the selector that matches this component and the pseudo element, if specified.
			var className = this.__getBackgroundClassName();
			var selector = "." + className + pseudo;

			var rules = stylesheet.cssRules;
			var count = rules.length;
			for (var i = 0; i < count; i++) {

				var rule = rules[i];
				if (rule.selectorText === selector) {
					var el = target.getContentElement();
					if (el)
						el.addClass(className);

					return rule;
				}
			}

			var el = target.getContentElement();
			if (el == null)
				return null;

			// create the css rule.
			var padding =
				target.getPaddingTop() + "px " +
				target.getPaddingRight() + "px " +
				target.getPaddingBottom() + "px " +
				target.getPaddingLeft() + "px";

			this.__cssRuleSelector = selector;
			qx.bom.Stylesheet.addRule(stylesheet,
				selector,
				"content:\"\"; display:block;position:absolute;top:0px;left:0px;width:100%;height:100%;z-index:-1;padding:" + padding);

			// assign the class to this element.
			el.addClass(className);

			// attach to the change of the padding to copy the padding to the
			// background image overlay :after element.
			this.addListener("changePadding", function (e) {

				var cssRuleAfter = this.__getCssRule(target, "::after");
				if (cssRuleAfter && cssRuleAfter.style) {

					var ruleStyle = cssRuleAfter.style;

					// update the padding.
					var padding =
						target.getPaddingTop() + "px " +
						target.getPaddingRight() + "px " +
						target.getPaddingBottom() + "px " +
						target.getPaddingLeft() + "px";

					ruleStyle.padding = padding;
				}
			});

			// detect changes the text color to update the fill on svg background images.
			this.addListener("changeTextColor", function (e) {
				this._updateBackgroundImages();
			});

			return this.__getCssRule(target, pseudo);
		}
	}
});


/**
 * wisej.mixin.MWisejControl
 * 
 * All Wisej controls must include this mixin to be recognized
 * by the Wisej.Core implementation.
 */
qx.Mixin.define("wisej.mixin.MWisejControl", {

	include: [
		wisej.mixin.MWisejComponent,
		wisej.mixin.MBackgroundImage,
		qx.ui.core.MResizable,
		qx.ui.core.MMovable
	],

	/**
	 * construct
	 *
	 * Initialize properties, add listeners to keep mapped properties in sync, add
	 * design time render listener, initialize movable/resizable common state.
	 */
	construct: function () {

		// initialize state events.
		this.initStateEvents();

		// widgets cannot be resized or moved on the client by default.
		this.setMovable(false);
		this.setResizable(false);

		// all wisej controls can shrink and grow.
		this.setAllowGrowX(true);
		this.setAllowGrowY(true);
		this.setAllowShrinkX(true);
		this.setAllowShrinkY(true);

		this.addListener("changeDroppable", this._onChangeDroppable);

		if (wisej.web.DesignMode) {

			// when in design mode, invoke this.__onDesignRender to let
			// the widget being designed fire the "render" event in order
			// to notify the designer that it's ready to be rendered.
			this.addListenerOnce("appear", function (e) {
				this.__onDesignRender(e);
			});
		}

		this.initTopLevel();
	},

	/**
	 * destruct
	 * 
	 * - Removes the widget from our global registry.
	 * - Unregisters the widget from its container.
	 */
	destruct: function () {

		if (wisej.web.DesignMode)
			return;

		// remove all wisej wired handlers.
		this.setWiredEvents(null);

		// unregister from the "App" namespace.
		if (this.isTopLevel())
			this.core.unregisterComponent(this, window.App);

		// unregister from parent and clear the parent reference.
		var parent = this.getParent();
		this.core.unregisterComponent(this, parent);
		if (parent)
			qx.util.PropertyUtil.setUserValue(this, "parent", null);

		// release related objects.
		this._disposeObjects("__blocker");
	},

	events: {

		/**
		 * Fired when the parent of the widget is changed.
		 * 
		 * The data object is a map: {newParent, oldParent}.
		 */
		changeParent: "qx.event.type.Data"
	},

	properties: {

		/**
		 * The X location of the control within its parent.
		 * 
		 * Property defined with the setter/getter methods.
		 */
		// x: { init: 0, check: "Integer" },

		/**
		 * The Y location of the control within its parent.
		 * 
		 * Property defined with the setter/getter methods.
		 */
		// y: { init: 0, check: "Integer" },

		/**
		 * Indicates that the component is "dirty"
		 * and needs to send its new state back to the server.
		 *
		 * Property defined with the setter/getter methods.
		 */
		// dirty: { init: false, check: "Boolean" },

		/**
		 * Collection of child controls.
		 *
		 * The collection always contains an array of widgets.
		 * 
		 * The incoming value can be:
		 *
		 *		- Array of widget instances.  
		 *		- Array of IDS. In which case all the widgets must have been created already.
		 *		- Array of widget definitions, that is the JSON definition of the widgets.
		 *
		 * Property defined with the setter/getter methods.
		 */
		// controls: { init: null, check: "Array", apply: "_applyControls", transform: "_transformComponents" },

		/**
		 * Signals that the controls collection must be added in reverse order.
		 */
		reverseControls: { init: true, check: "Boolean" },

		/**
		 *  ImeMode.
		 *
		 * Sets the ime-mode css style.
		 */
		imeMode: { init: null, nullable: true, check: "String", apply: "_applyImeMode" },

		/**
		 * The visible property.
		 * 
		 * Property defined with the setter/getter methods.
		 */
		// visible: { init: false, check: "Boolean", apply: "setVisible" },

		/**
		 * MouseCapture property.
		 * 
		 * When set to true, the widget captures all mouse events.
		 */
		mouseCapture: { init: false, check: "Boolean", apply: "_applyMouseCapture" },

		/**
		 * ResizableEdges property.
		 * 
		 * Sets the resizable edges of the control.
		 * The value is an array: ["left", "top", "right", "bottom"].
		 */
		resizableEdges: { init: null, check: "Array", apply: "_applyResizableEdges", nullable: true, event: "changeResizableEdges" },

		/**
		 * Movable property.
		 * 
		 * When set to true, the widget can be dragged on the screen.
		 */
		allowMove: { init: false, check: "Boolean", apply: "_applyAllowMove", event: "changeAllowMove" },

		/**
		 * The childIndex property.
		 *
		 * Property defined with the setter/getter methods. It needs to be called also when the value is not changed
		 * since the z-index or childIndex is relative to the other siblings.
		 */
		// childIndex: { init: 0, check: "PositiveInteger", apply: "_applyChildIndex", event: "changeChildIndex" },

		/**
		 * TabStop property.
		 *
		 * Determines whether the control can be focused in the tab order.
		 */
		tabStop: { init: false, check: "Boolean" },

		/**
		 * The parent widget.
		 * 
		 * This is not the layout parent as defined by QX, this is the parent
		 * defined by the server code.
		 *
		 * The incoming value can be the widget ID or the widget instance.
		 */
		parent: { init: null, apply: "_applyParent", nullable: true, transform: "_transformComponent" },

		/**
		 * The contextual menu.
		 * 
		 * Replaces the built-in contextMenu.
		 */
		contextMenu: { init: null, nullable: true, apply: "_applyContextMenu", transform: "_transformMenu" },

		/**
		 * Indicates that the control is a top level
		 * window, that is usually a form, a page or a dialog box.
		 */
		topLevel: { init: false, check: "Boolean", apply: "_applyTopLevel" },

		/**
		 * Accessibility property.
		 *
		 * Sets the combination  of accessibility attributes on the current element:
		 *
		 *    name = the name attributes.
		 *    description = the alt attribute.
		 *    role = the role attribute.
		 */
		accessibility: { init: null, check: "Map", apply: "_applyAccessibility" },

		/**
		 * AutoShowLoader property.
		 * 
		 * When true, the ajax loader blocks the browser when the "execute" event is
		 * fired. NOTE: It's up to the server control to hide the loader once
		 * execution is completed.
		 */
		autoShowLoader: { init: false, check: "Boolean", apply: "_applyAutoShowLoader" },

		/**
		 * EnableTouchEvents property.
		 *
		 * When true, we attach to the touch events and convert them to data events
		 * that can be managed by the server.
		 */
		enableTouchEvents: { init: false, check: "Boolean", apply: "_enableTouchEvents" },

		/**
		 * List of properties that should be included in the state.
		 */
		stateProperties: { init: ["x", "y", "width", "height", "visible", "enabled"], check: "Array", nullable: true },

		/**
		 * List of events that causes this component to be marked dirty.
		 */
		stateEvents: { init: ["move", "resize", "changeVisibility", "changeEnabled"], check: "Array", apply: "_applyStateEvents", nullable: true },

		/**
		 * Map of custom defined theme states, initialization script, event listeners and css class names.
		 */
		clientConfig: { check: "Map", apply: "_applyClientConfig" }
	},

	members: {

		/**
		 * Wisej marker.
		 */
		isWisejControl: true,

		// indicates that the component is in the middle
		// of updating its state.
		__inSetState: false,

		/** blocker widget. */
		__blocker: null,

		/**
		 * updateState
		 *
		 * Updates the state of the component and returns the difference
		 * with the previous state.
		 * 
		 * @param propertyNames {String | Array | null} 
		 *		Name of the state property or array of properties to update. The default is to update all state properties.
		 * 
		 */
		updateState: function (propertyNames) {

			if (wisej.web.DesignMode)
				return;

			var properties = this.getStateProperties();
			if (!properties || properties.length === 0)
				return;

			// clone the state first.
			var newState = {};
			var storedState = this.$state;
			if (storedState) {
				for (var i = 0, l = properties.length; i < l; i++) {
					newState[properties[i]] = storedState[properties[i]];
				}
			}

			// normalize the property names to filter the properties to update.
			var propArray = null;
			if (propertyNames) {
				if (propertyNames instanceof Array)
					propArray = propertyNames;
				else
					propArray = [propertyNames];
			}

			var value, name;
			for (var i = 0, l = properties.length; i < l; i++) {

				try {

					name = properties[i];
					value = this.get(name);

					// update only the specified property?
					if (propArray && propArray.indexOf(name) === -1)
						continue;

					// convert widget references to their id.
					if (value instanceof qx.ui.core.Widget) {
						if (value.getId)
							value = value.getId();
						else
							return;
					}
					// clone objects to break cross references.
					else if (value instanceof Object) {
						value = qx.lang.Object.clone(value, true);
					}

					newState[name] = value;
				}
				catch (error) {
					if (this.core)
						this.core.logError(error);
				}
			}

			// let the widget have a shot at the collected state.
			if (this.getState)
				newState = this.getState(newState);

			// diff the stored state and the new state.
			var diffState = this.core.diffState(storedState, newState);
			if (diffState)
				diffState.id = this.getId();

			// update the stored state.
			this.$state = newState;

			// return only the differences.
			return diffState;
		},

		/**
		 * resetState
		 *
		 * Clears the saved state. The next call to updateState()
		 * will return the full state of the component.
		 */
		resetState: function () {

			this.$state = null;

		},

		/**
		 * Applies the state.
		 *
		 * Updates the component state.
		 *
		 * @param state {Map} state properties.
		 */
		setState: function (state) {

			// update the component and the stored state.
			this.__inSetState = true;
			try {

				this.set(state);

				// safeguard to prevent the widget to update the full state
				// if it's still dirty, or the server may lose the current state.
				this.updateState(this.getDirty() ? Object.keys(state) : null);

			} catch (error) {

				if (this.core)
					this.core.logError(error);
			}
			this.__inSetState = false;
		},

		/**
		 * Returns whether the widget is reachable by pressing the TAB key.
		 *
		 * Tests for both, the focusable property and a positive or
		 * undefined tabIndex property. The widget must have a DOM element
		 * since only visible widgets are tabable.
		 */
		isTabable: function () {

			// having a DOM element is not enough, hidden widgets have a DOM element too.
			var dom = this.getContentElement().getDomElement();
			if (!dom || dom.offsetWidth == 0)
				return false;

			// not tabable if a UserControl widget in the parent path has tabStop = false.
			for (var parent = this.getParent(); parent != null; parent = parent.getParent()) {
				if (parent instanceof wisej.web.UserControl && !parent.isTabStop())
					return false;
			}

			return this.isTabStop() && this.isFocusable();
		},

		/**
		 * Gets/Sets the dirty property.
		 */
		getDirty: function () {

			if (wisej.web.DesignMode)
				return false;

			return this.core.isDirty(this);
		},
		setDirty: function (value) {

			if (wisej.web.DesignMode)
				return;

			this.core.setDirty(this, value);
		},

		/**
		 * Gets/Sets the visible property.
		 */
		getVisible: function () {
			return this.getVisibility() === "visible";
		},
		setVisible: function (value) {
			this.setVisibility(value ? "visible" : "excluded");
		},

		/**
		 * Applies the childIndex property.
		 */
		getChildIndex: function () {

			var parent = this.getParent();
			if (!parent)
				return 0;

			var children = parent.getControls();
			var index = children.indexOf(this);

			if (parent.isReverseControls()) {
				var count = children.length;
				index = count - index - 1;
			}
			return index;
		},
		setChildIndex: function (value) {

			var parent = this.getParent();
			if (parent) {

				var index = value;
				var currentIndex = this.getChildIndex();
				var count = parent.getControls().length;
				index = Math.max(0, Math.min(index, count - 1));

				if (index === currentIndex)
					return;

				var forward = (index < currentIndex);

				if (parent.isReverseControls()) {
					// we must keep the child index in reverse order
					// since the dom element order is the opposite of z-order.
					index = count - index - 1;
					index = Math.max(0, index);
				}

				if (parent.addAt)
					parent.addAt(this, index);
				else
					parent._addAt(this, index);

				// update the dom order.
				var thisEl = this.getContentElement();
				if (thisEl) {
					var domIndex = index + (forward ? 1 : 0);
					thisEl.moveTo(domIndex);
				}

				this.fireDataEvent("changeChildIndex", index, currentIndex);
			}
		},

		/**
		 * Shows the ajax loader over the widget.
		 */
		showLoader: function () {
			this.getBlocker().block();
		},

		/**
		 * Hides the ajax loader over the widget.
		 */
		hideLoader: function () {
			if (this.__blocker)
				this.__blocker.forceUnblock();
		},

		/**
		 * Returns a {qx.ui.core.Blocker} widget that
		 * overlays this widget.
		 */
		getBlocker: function () {

			if (!this.__blocker) {

				var blocker = new qx.ui.core.Blocker(this);
				blocker.setColor("loaderBackground");
				blocker.setBackgroundImage("ajax-loader");

				this.__blocker = blocker;
			}

			return this.__blocker;
		},

		/**
		 * Applies the TabIndex property.
		 */
		_applyTabIndex: function (value, old) {

			if (this.isWisejContainer)
				return;

			if (this.getFocusable() && value > 0)
				this.getFocusElement().setAttribute("tabIndex", value);
			else
				this.getFocusElement().removeAttribute("tabIndex");
		},

		/**
		 * Captures the mouse.
		 */
		_applyMouseCapture: function (value, old) {
			this.capture(value);
		},

		/**
		 * Applies the ime-mode css.
		 */
		_applyImeMode: function (value, old) {

			var elem = this.getContentElement();
			elem.setStyle("imeMode", value);
		},

		/**
		 * Sets the resizable edges.
		 */
		_applyResizableEdges: function (value, old) {

			var edges = [false, false, false, false];

			if (value) {
				for (var i = 0; i < value.length; i++) {
					switch (value[i]) {
						case "top": edges[0] = true; break;
						case "left": edges[3] = true; break;
						case "right": edges[1] = true; break;
						case "bottom": edges[2] = true; break;
					}
				}
			}

			this.setResizable(edges);
		},

		/**
		 * Allows the widget to be moved across the screen.
		 */
		_applyAllowMove: function (value, old) {

			if (value == old)
				return;

			this.setMovable(value);

			if (value && this.__moveHandle == null)
				this._activateMoveHandle(this);
		},

		/**
		 * Applies the topLevel property.
		 * 
		 * TopLevel components are registered in the global namespace.
		 */
		_applyTopLevel: function (value, old) {

			if (wisej.web.DesignMode)
				return;

			// make sure we have the App instance.
			window.App = window.App || {};

			// unregister, if previously registered as a child control
			if (old) {
				this.core.unregisterComponent(this, window.App);
				qx.ui.core.FocusHandler.getInstance().removeRoot(this);
			}

			// re-register as a top-level control.
			if (value) {
				this.core.registerComponent(this, window.App);
				qx.ui.core.FocusHandler.getInstance().addRoot(this);
			}	
		},

		/**
		 * Applies the autoShowLoader property.
		 */
		_applyAutoShowLoader: function (value, old) {

			if (this.__showLoaderListenerId) {
				this.removeListenerById(this.__showLoaderListenerId);
				this.__showLoaderListenerId = null;
			}

			if (value) {
				this.__showLoaderListenerId = this.addListener("execute", function (e) {
					this.core.showLoader(true);
				});
			}
		},

		/** id of the showLoader "execute" handler. */
		__showLoaderListenerId: null,

		/**
		 * Applies the accessibility attributes.
		 */
		_applyAccessibility: function (value, old) {

			var el = this.getAccessibilityElement();
			if (el) {

				if (value) {
					el.setAttributes({
						name: value.name,
						alt: value.description,
						role: value.role.toLowerCase()
					});
				}
				else {
					el.setAttributes({
						alt: null,
						name: null,
						role: null,
					});
				}
			}
		},

		/**
		 * Applies the enableTouchEvents property.
		 */
		_enableTouchEvents: function (value, old) {

			var el = this.getContentElement();

			if (value) {

				this.addListener("touchstart", this.__onTouchEvent);
				this.addListener("touchend", this.__onTouchEvent);
				this.addListener("touchcancel", this.__onTouchEvent);
				this.addListener("touchmove", this.__onTouchEvent);
				this.addListener("swipe", this.__onTouchEvent);
				this.addListener("pinch", this.__onTouchEvent);
				this.addListener("track", this.__onTouchEvent);
				this.addListener("rotate", this.__onTouchEvent);
			}
			else {
				this.removeListener("touchstart", this.__onTouchEvent);
				this.removeListener("touchend", this.__onTouchEvent);
				this.removeListener("touchcancel", this.__onTouchEvent);
				this.removeListener("touchmove", this.__onTouchEvent);
				this.removeListener("swipe", this.__onTouchEvent);
				this.removeListener("pinch", this.__onTouchEvent);
				this.removeListener("track", this.__onTouchEvent);
				this.removeListener("rotate", this.__onTouchEvent);
			}
		},

		// Converts native/qooxdoo touch event arguments into a data package for
		// wisej to be able to route the event to the control.
		__onTouchEvent: function (e) {

			// find the original wisej target for the event.
			var originalTarget = wisej.utils.Widget.findWisejComponent(e.getOriginalTarget());

			// dispatch bubbled events only to the actual target and not the bubbled up target, otherwise
			// a parent control will get the events on the child controls.
			if (originalTarget && originalTarget !== this && !originalTarget.hasState("inner"))
				return;

			switch (e.getType()) {

				case "touchstart":
					this.fireDataEvent("touch.start", this.__getTouchData(e));
					break;

				case "touchend":
					this.fireDataEvent("touch.end", this.__getTouchData(e));
					break;

				case "touchcancel":
					this.fireDataEvent("touch.cancel", this.__getTouchData(e));
					break;

				case "touchmove":
					this.fireDataEvent("touch.move", this.__getTouchData(e));
					break;

				case "pinch":
					this.fireDataEvent("touch.pinch", e.getScale());
					break;

				case "swipe":
					this.fireDataEvent("touch.swipe", {
						axis: e.getAxis(),
						startTime: e.getStartTime(),
						duration: e.getDuration(),
						direction: e.getDirection(),
						velocity: e.getVelocity(),
						distance: e.getDistance()
					});
					break;

				case "rotate":
					this.fireDataEvent("touch.rotate", e.getAngle());
					break;

				case "track":
					this.fireDataEvent("touch.track", e.getDelta());
					break;
			}

		},

		// Extract usable data from the touch event.
		__getTouchData: function (e) {

			var list = [];
			var touches = e.getTargetTouches();
			for (var i = 0; i < touches.length; i++) {
				list.push({
					id: e.getIdentifier(i),
					screenX: e.getDocumentLeft(i) | 0,
					screenY: e.getDocumentTop(i) | 0,
				});
			}

			return {
				touches: list,
				scale: e.getScale(),
				rotation: e.getRotation(),
				multiTouch: e.isMultiTouch()
			};

		},

		/**
		 * Applies the controls property.
		 * 
		 * Sets this widget as the parent of each child
		 * and adds the child control to this widget"s
		 * children container.
		 */
		getControls: function () {

			return this.getChildren
				? this.getChildren()
				: this._getChildren();
		},
		setControls: function (value) {

			var old = this.getControls();
			var controls = this._transformComponents(value);

			// remove all existing child widgets that are not present in the new collection.
			if (old != null && old.length > 0) {

				// dereference the children array or the loop
				// will skip widgets as it shrinks.
				old = old.concat();

				for (var i = 0; i < old.length; i++) {
					var child = old[i];
					if (child != null && child.isWisejControl) {
						if (controls && controls.indexOf(child) == -1)
							child.setParent(null);
					}
				}
			}

			if (controls != null && controls.length > 0) {

				// assign the parent to the widgets in the collection in reverse order
				// to keep the z-order in sync with the collection order on the server.
				if (this.isReverseControls()) {

					for (var i = controls.length - 1; i > -1; i--) {
						var child = controls[i];
						if (child != null && child.isWisejControl)
							child.setParent(this);
					}
				}
				else {

					for (var i = 0; i < controls.length; i++) {
						var child = controls[i];
						if (child != null && child.isWisejControl)
							child.setParent(this);
					}
				}
			}

			this.fireEvent("controlsChanged");
		},

		/**
		 * Applies the contextMenu property.
		 */
		_applyContextMenu: function (value, old) {

			if (old) {
				old.removeState("contextmenu");

				if (old.getOpener() == this) {
					old.resetOpener();
				}
			}

			if (value) {

				value.setOpener(this);
				value.addState("contextmenu");

				if (!old) {
					this.addListener("longtap", this._onContextMenuOpen, this);
					this.addListener("contextmenu", this._onContextMenuOpen, this);
				}

				// rightToLeft support.
				value.setRtl(this.getRtl());
			}
			else {
				this.removeListener("longtap", this._onContextMenuOpen, this);
				this.removeListener("contextmenu", this._onContextMenuOpen, this);
			}
		},

		/**
		 * Gets/Sets the "x" (left) property.
		 */
		getX: function () {

			return this.getLayoutProperties().left;
		},
		setX: function (value) {

			this.setLayoutProperties({ left: value });
			this.__updateUserBounds();
		},

		/**
		 * Gets/Sets the "y" (top) property.
		 */
		getY: function () {

			return this.getLayoutProperties().top;
		},
		setY: function (value) {

			this.setLayoutProperties({ top: value });
			this.__updateUserBounds();
		},

		/**
		 * Fires a "widgetEvent" with the specified data.
		 *
		 * @param type {String} the event type.
		 * @param data {Map} The event data map.
		 */
		fireWidgetEvent: function (type, data) {

			this.fireDataEvent("widgetEvent", { type: type, data: data });

		},

		// overridden.
		_applyDimension: function (value, old, name) {

			switch (name) {
				case "width":
				case "height":
					this.__updateUserBounds();
					break;
			}

			qx.ui.core.queue.Layout.add(this);
		},

		// update the user bounds when this is a child control
		// that is not inside a wisej container.
		//
		// Note: Wisej containers are widgets that are marked with the
		// isWisejContainer member set to true. Containers manage their own
		// internal layout and child widgets should not set their user bounds.
		__updateUserBounds: function () {

			var parent = this.getParent();
			if (parent != null && !parent.isWisejContainer) {

				var top = this.getY();
				if (top == null)
					return;

				var left = this.getX();
				if (left == null)
					return;

				var width = this.getWidth();
				if (width == null)
					return;

				var height = this.getHeight();
				if (height == null)
					return;

				this.setUserBounds(left, top, width, height);
			}
		},

		/**
		 * Applies the parent property.
		 * 
		 * Saves a reference to the parent widget
		 * and registers this widget in the parent"s namespace.
		 */
		_applyParent: function (value, old) {

			// in case we are changing the parent,
			// unregister the component from the global namespace
			// and remove it from the parent's children.
			if (old) {

				if (!wisej.web.DesignMode)
					this.core.unregisterComponent(this, old);

				try {

					if (old.indexOf && old.indexOf(this) > -1)
						old.remove(this);
					else if (old._indexOf && old._indexOf(this) > -1)
						old._remove(this);

					this.resetUserBounds();

				} catch (ex) {

					// ignore this error.
				}
			}

			// register with the new parent
			if (value) {

				if (!wisej.web.DesignMode)
					this.core.registerComponent(this, value);

				// update the appearance key.
				this._setChildAppearance(value);

				if (value.add) {
					value.add(this);
				}
				else {
					value._add(this);
				}

				// update the user bounds in case this control
				// is being parented by a control with a layout
				// that cannot handle non-user bounds.
				this.__updateUserBounds();
			}

			// fire the "parentChanged" event.
			this.fireDataEvent("changeParent", { newParent: value, oldParent: old });
		},

		/**
		* Applies the state events property.
		*
		* Attach a listener for the state events that
		* marks the component as dirty.
		*/
		_applyStateEvents: function (value, old) {

			// detach old listeners not listed in the new list
			if (old != null && old.length > 0) {
				for (var i = 0; i < old.length; i++) {
					this.removeListener(old[i], this._stateEventHandler, this);
				}
			}

			// attach the property change listener to the state properties
			if (value != null && value.length > 0) {
				for (var i = 0; i < value.length; i++) {
					this.addListener(value[i], this._stateEventHandler, this);
				}
			}
		},

		/**
		 * _stateEventHandler
		 *
		 * Listens to state events and marks the component as dirty.
		 */
		_stateEventHandler: function (e) {

			this.setDirty(true);
		},

		/**
		 * Applies the clientConfig property.
		 */
		_applyClientConfig: function (value, old) {

			// "class"
			// set the css class name.
			if ((value && value.class) || (old && old.class)) {

				var el = this.getContentElement();
				var cssNames = (el.getAttribute("class") || "").split(" ");

				// remove the old class list from the current class name.
				if (old && old.class && cssNames.length > 0) {
					var oldNames = old.class.split(" ");
					qx.lang.Array.exclude(cssNames, oldNames);
				}

				// remove the new class list from the current class name
				// to make sure the css class names are listed once.
				if (value && value.class) {
					var newNames = value.class.split(" ");
					if (cssNames.length > 0)
						qx.lang.Array.exclude(cssNames, newNames);

					// now add new names back.
					cssNames = cssNames.concat(newNames);
				}

				el.setAttribute("class", cssNames.join(" "));
			}

			// "style"
			// set the custom style.
			if ((value && value.style) || (old && old.style)) {

				var el = this.getContentElement();

				// remove the previously added styles.
				if (old && old.style) {

					var style = old.style;
					for (var key in style) {
						style[key] = null;
					}
					el.setStyles(style);
				}

				// add the new styles.
				// the "style" property when set is just a string. we need
				// to convert it to a collection of styles. the easiest
				// way is to use a dummy div.
				if (value && value.style) {
					value.style = wisej.utils.Widget.parseCss(value.style);
					el.setStyles(value.style);
				}
			}

			// "states"
			// update the custom states: value.states[].
			if (old && old.states && old.states.length > 0) {
				for (var i = 0, l = old.states.length; i < l; i++)
					this.removeState(old.states[i]);
			}
			if (value && value.states && value.states.length > 0) {
				for (var i = 0, l = value.states.length; i < l; i++)
					this.addState(value.states[i]);
			}

			// don't execute the init or attach the listeners when in design  mode.
			// we don't want custom code to run in the designer.
			if (wisej.web.DesignMode)
				return;

			// "init"
			// execute the init script once when the 
			// widget is made visible the first time: value.init.
			if (value && value.init && (!old || !old.init)) {
				this.addListenerOnce("appear", function () {
					var script = this.getClientConfig().init;
					if (script) {
						var func = new Function(script);
						func.call(this);
					}
				}, this);
			}

			// "listeners"
			// attach/detach custom listeners.
			if (old && old.listeners && old.listeners.length > 0) {
				for (var i = 0, l = old.listeners.length; i < l; i++) {
					var id = old.listeners[i].id;
					if (id) {
						this.removeListenerById(id);
					}
				}
			}
			if (value && value.listeners && value.listeners.length > 0) {
				for (var i = 0, l = value.listeners.length; i < l; i++) {
					var name = value.listeners[i].event;
					var script = value.listeners[i].javaScript;
					if (name && script) {
						value.listeners[i].id = this.addListener(name, new Function("e", script));
					}
				}
			}
		},

		/**
		* Register with the global drag manager when Droppable changes.
		*/
		_onChangeDroppable: function (e) {

			// register this widget for the native html5 file drag-drop handling.
			var dragDrop = wisej.web.DragDrop.getInstance();
			if (dragDrop) {

				if (e.getData())
					dragDrop.registerComponent(this);
				else if (e.getOldData())
					dragDrop.unregisterComponent(this);
			}
		},

		/**
		 * If the widget is in design mode, this handler
		 * fires the "render" event, which is used by the designer
		 * to know that the widget is ready to be scraped.
		 *
		 * If the widget implements a method _onDesignRender it calls it and it's
		 * now the widget's responsibility to fire "render".
		 *
		 * If the widget is NOT in design mode, this handler
		 * enables the firing of state and all other events.
		 */
		__onDesignRender: function (e) {

			if (wisej.web.DesignMode) {

				if (this._onDesignRender)
					this._onDesignRender();
				else
					this.fireEvent("render");
			}
		}
	}

});


/**
 * wisej.mixin.MWisejMenu
 * 
 * All Wisej menu classes must include this mixin to be recognized
 * by the Wisej.Core implementation.
 */
qx.Mixin.define("wisej.mixin.MWisejMenu", {

	include: [wisej.mixin.MWisejComponent],

	properties: {

		/**
		 * Collection of child menu items.
		 *
		 * The collection always contains an array of widgets.
		 * 
		 * The incoming value can be:
		 *
		 *		- Array of widget instances.  
		 *		- Array of IDS. In which case all the widgets must have been created already.
		 *		- Array of widget definitions, that is the JSON definition of the widgets.
		 */
		menuItems: { init: [], apply: "_applyMenuItems", transform: "_transformMenuItems" },

		/**
		 * Parent property.
		 *
		 * This is the parent of the menu item.
		 */
		parent: { init: null, nullable: true, apply: "_applyParent", transform: "_transformComponent" },

		/**
		 * Mnemonic property.
		 *
		 * Registers the mnemonic character as a shortcut to the execute function on this widget.
		 * The character is register as a Alt+[character] command.
		 */
		mnemonic: { init: null, check: "String", apply: "_applyMnemonic", event: "changeMnemonic" },

		/**
		 * Shortcut property.
		 *
		 * Enables the shortcut for the menu item.
		 */
		shortcut: { init: null, check: "String", apply: "_applyShortcut", transform:"_transformShortcut", event: "changeShortcut" },

		/**
		 * AutoShowLoader property.
		 * 
		 * When true, the ajax loader blocks the browser when the "execute" event is
		 * fired. NOTE: It's up to the server control to hide the loader once
		 * execution is completed.
		 */
		autoShowLoader: { init: false, check: "Boolean", apply: "_applyAutoShowLoader" },

		/**
		 * Accessibility property.
		 *
		 * Sets the combination  of accessibility attributes on the current element:
		 *
		 *    name = the name attributes.
		 *    description = the alt attribute.
		 *    role = the role attribute.
		 */
		accessibility: { init: null, check: "Map", apply: "_applyAccessibility" }
	},

	members: {

		/**
		 * Wisej marker.
		 */
		isWisejMenu: true,

		/**
		 * Transforms the incoming collection of child widgets
		 * by converting the widget id to the widget instance.
		 */
		_transformMenuItems: function (value) {

			if (value == null || value.length == 0)
				return value;

			// list of json definitions?
			if (typeof value[0] !== "string") {

				// collection of widgets?
				if (value[0] instanceof qx.ui.core.Widget) {

					value = value;

				}
				else {

					var widgets = [], widget, config;

					// create the widgets from the config data.
					for (var i = 0; i < value.length; i++) {

						widget = null;
						config = value[i];

						if (wisej.web.DesignMode)
							widget = this._createDesignTimeComponent(config);
						else
							widget = this.core.createComponent(config);

						if (widget)
							widgets.push(widget);
					}
					value = widgets;
				}
			}
			else {

				var widgets = [], widget;

				if (!wisej.web.DesignMode) {
					// resolve the widget from the IDs.
					for (var i = 0; i < value.length; i++) {

						widget = this.core.getComponent(value[i]);

						if (widget)
							widgets.push(widget);
					}
				}

				value = widgets;
			}

			return value;
		},

		/**
		 * Applies the parent property.
		 */
		_applyParent: function (value, old) {

			// remove from the previous owner/parent.
			if (old != null) {

				// menu items must have a menu as their parent.
				var menu = old;
				if (menu.getMenu)
					menu = menu.getMenu();

				if (menu != null && menu.indexOf(this) > -1)
					menu.remove(this);
			}

			if (value != null) {

				// menu items must have a menu as their parent.
				var menu = value;
				if (menu.getMenu)
					menu = menu.getMenu();

				// create the child popup menu.
				if (menu == null && value.setMenu) {
					menu = new qx.ui.menu.Menu();

					// fire the popup event when the child menu appears.
					var parent = value;
					menu.addListener("appear", function (e) {
						parent.fireEvent("popup");
					}, this);

					value.setMenu(menu);
				}

				if (menu) {
					// update the appearance key.
					this._setChildAppearance(menu);

					menu.add(this);
				}
			}
		},

		/**
		 * Applies the showLoader property.
		 */
		_applyAutoShowLoader: function (value, old) {

			if (this.__showLoaderListenerId) {
				this.removeListenerById(this.__showLoaderListenerId);
				this.__showLoaderListenerId = null;
			}

			if (value) {
				this.__showLoaderListenerId = this.addListener("execute", function (e) {
					this.core.showLoader(true);
				});
			}
		},

		/** id of the showLoader "execute" handler. */
		__showLoaderListenerId: null,

		/**
		 * Applies the shortcut property.
		 */
		_applyShortcut: function (value, old) {

			if (!value && old) {
				wisej.web.manager.Accelerators.getInstance().unregister(old, this.__onShortcut, this);
			}

			if (value && !old) {
				wisej.web.manager.Accelerators.getInstance().register(value, this.__onShortcut, this);
			}

		},

		_transformShortcut: function (value) {

			return wisej.utils.Widget.translateAcceleratorKey(value);
		},

		__onShortcut: function (e) {

			// ignore Del and Backspace when in an input field.
			var target = e.getTarget();
			if (target.tagName) {
				switch (e.getKeyIdentifier()) {
					case "Delete":
					case "Backspace":
						var tagName = target.tagName.toLowerCase();
						if (tagName === "input" || tagName === "textarea")
							return;
				}
			}

			// ignore shortcuts on menu items on menu bars that are hidden or not
			// in an active top-level container: page, form, or desktop.
			var container = this.findContainer();
			if (container && !container.isVisible())
				return;
			if (!wisej.utils.Widget.canExecute(container))
				return;

			if (this.executeShortcut && this.executeShortcut()) {
				e.preventDefault();
				return true; // stop dispatching
			}
		},

		/**
		 * Applies the mnemonic property.
		 *
		 * Registers a command for the Alt+[mnemonic] shortcut.
		 */
		_applyMnemonic: function (value, old) {

			if (!value && old) {
				this.removeState("mnemonic");
				wisej.web.manager.Accelerators.getInstance().unregister("Alt" + old, this.__onMnemonic, this);
			}

			if (value && !old) {
				this.addState("mnemonic");
				wisej.web.manager.Accelerators.getInstance().register("Alt+" + value.toUpperCase(), this.__onMnemonic, this);
			}
		},

		__onMnemonic: function (e) {

			// ignore mnemonics on menu items on menu bars that are hidden or not
			// in an active top-level container: page, form, or desktop.
			var container = this.findContainer();
			if (container && !container.isVisible())
				return;
			if (!wisej.utils.Widget.canExecute(container))
				return;

			// stop dispatching when a widget processes the mnemonic.
			return this.executeMnemonic && this.executeMnemonic();
		},

		/**
		 * Applies the menuItems property.
		 */
		_applyMenuItems: function (value, old) {

			var menu = this;
			if (this.getMenu)
				menu = this.getMenu();

			// ignore for menu separators.
			if (menu instanceof qx.ui.menu.Separator)
				return;

			if (menu) {
				var items = menu.removeAll();
				if (items && items.length > 0) {
					for (var i = 0; i < items.length; i++) {
						items[i].setParent(null);
					}
				}
			}

			if (value && value.length > 0) {

				// add the menu items to the menu container.
				for (var i = 0; i < value.length; i++) {
					value[i].setParent(this);
				}
			}
		},

		/**
		 * Finds the top container of the menu item triggered by the accelerator or mnemonic.
		 */
		findContainer: function () {

			var container = null;
			for (var parent = this.getParent();
				parent != null;
				parent = parent.getParent()) {

				if (parent.getUserData("container")) {
					container = parent.getUserData("container");
					break;
				}
				if (parent.getParent() == null) {
					container = parent;
					break;
				}
			}

			return container;
		},

		/**
		 * Applies the accessibility attributes.
		 */
		_applyAccessibility: function (value, old) {

			var el = this.getAccessibilityElement();
			if (el) {

				if (value) {
					el.setAttributes({
						name: value.name,
						alt: value.description,
						role: value.role.toLowerCase()
					});
				}
				else {
					el.setAttributes({
						alt: null,
						name: null,
						role: null
					});
				}
			}
		}
	},

	/**
	 * destruct
	 */
	destruct: function () {
		wisej.web.manager.Accelerators.getInstance().unregister(this.getShortcut(), this.__onShortcut, this);
		wisej.web.manager.Accelerators.getInstance().unregister("Alt+" + this.getMnemonic(), this.__onMnemonic, this);
	}

});


/**
 * wisej.mixin.MShortcutTarget
 * 
 * Adds support for shortcut and mnemonic handling.
 */
qx.Mixin.define("wisej.mixin.MShortcutTarget", {

	properties: {

		/**
		 * Mnemonic property.
		 *
		 * Registers the mnemonic character as a shortcut to the execute function on this widget.
		 * The character is register as a Alt+[character] command.
		 */
		mnemonic: { init: null, check: "String", apply: "_applyMnemonic", event: "changeMnemonic" },

		/**
		 * Shortcut property.
		 *
		 * Registers the shortcut to the execute function on this widget.
		 */
		shortcut: { init: null, check: "String", apply: "_applyShortcut", transform:"_transformShortcut", event: "changeShortcut" }

	},

	members: {

		/**
		 * Applies the shortcut property.
		 *
		 * Registers an accelerator for the shortcut.
		 */
		_applyShortcut: function (value, old) {

			if (!value && old) {
				wisej.web.manager.Accelerators.getInstance().unregister(old, this.__onAccelerator, this);
			}

			if (value && !old) {
				wisej.web.manager.Accelerators.getInstance().register(value, this.__onAccelerator, this);
			}

		},

		_transformShortcut: function (value) {

			return wisej.utils.Widget.translateAcceleratorKey(value);
		},

		__onAccelerator: function (e) {

			// ignore shortcuts on widgets that are not
			// in an active top-level container: page, form, or desktop.
			if (!wisej.utils.Widget.canExecute(this))
				return;

			if (this.executeShortcut && this.executeShortcut()) {
				e.preventDefault();
				return true; // stop dispatching
			}
		},

		/**
		 * Applies the mnemonic property.
		 *
		 * Registers an accelerator for the Alt+[mnemonic].
		 */
		_applyMnemonic: function (value, old) {

			if (!value && old) {
				this.removeState("mnemonic");
				wisej.web.manager.Accelerators.getInstance().unregister("Alt+" + old, this.__onMnemonic, this);
			}

			if (value && !old) {
				this.addState("mnemonic");
				wisej.web.manager.Accelerators.getInstance().register("Alt+" + value.toUpperCase(), this.__onMnemonic, this);
			}
		},

		__onMnemonic: function (e) {

			// ignore mnemonics on widgets that are not
			// in an active top-level container: page, form, or desktop.
			if (!wisej.utils.Widget.canExecute(this))
				return;

			return this.executeMnemonic && this.executeMnemonic();
		}
	},

	/**
	 * destruct
	 */
	destruct: function () {
		wisej.web.manager.Accelerators.getInstance().unregister(this.getShortcut(), this.__onAccelerator, this);
		wisej.web.manager.Accelerators.getInstance().unregister("Alt+" + this.getMnemonic(), this.__onMnemonic, this);
	}

});


/**
 * wisej.mixin.MBorderStyle
 * 
 * Adds support for the BorderStyle property.
 */
qx.Mixin.define("wisej.mixin.MBorderStyle", {

	properties: {

		/**
		 * BorderStyle property.
		 */
		borderStyle: { init: "none", check: ["none", "solid", "dashed", "dotted", "double"], apply: "_applyBorderStyle" },

	},

	members: {

		/**
		 * Applies the borderStyle property.
		 *
		 * The borderStyles is applied as a state to be able to
		 * theme the styles.
		 */
		_applyBorderStyle: function (value, old) {

			if (old)
				this.removeState("border" + qx.lang.String.firstUp(old));

			if (value)
				this.addState("border" + qx.lang.String.firstUp(value));
		},

	}

});


/**
 * wisej.mixin.MAccelerators
 * 
 * Adds support for the Accelerators property.
 */
qx.Mixin.define("wisej.mixin.MAccelerators", {

	properties: {

		/**
		 * Accelerators property.
		 *
		 * Defines a list of keys that fire the "accelerator" event when pressed regardless of the focus.
		 */
		accelerators: { init: null, check: "Array", apply: "_applyAccelerators", transform: "_transformAccelerators" },

	},

	members: {

		/** accelerators map. */
		__accelerators: null,

		/**
		 * Applies the accelerators property.
		 */
		_applyAccelerators: function (value, old) {

			// unregister the previous commands.
			if (old != null && old.length > 0 && this.__accelerators) {

				for (var i = 0; i < old.length; i++) {

					if (value && value.indexOf(old[i]) > -1)
						continue;

					var key = qx.lang.String.firstUp(old[i]);
					delete this.__accelerators[key];
				}

				if (qx.lang.Object.isEmpty(this.__accelerators) && (value == null || value.length == 0)) {
					this.__accelerators = null;
					wisej.web.manager.Accelerators.getInstance().unregister(null, this.__onAccelerator, this);
				}
			}

			// register the new accelerators.
			if (value != null && value.length > 0) {

				// register to receive global keydown events the fist time we have an accelerator.
				if (this.__accelerators == null) {
					this.__accelerators = {};
					wisej.web.manager.Accelerators.getInstance().register(null, this.__onAccelerator, this);
				}

				for (var i = 0; i < value.length; i++) {
					var key = qx.lang.String.firstUp(value[i]);
					this.__accelerators[key] = true;
				}
			}
		},

		_transformAccelerators: function (value) {

			if (value && value.length) {
				for (var i = 0; i < value.length; i++) {
					value[i] = wisej.utils.Widget.translateAcceleratorKey(value[i]);
				}
			}

			return value;
		},

		__onAccelerator: function (e) {

			if (this.__accelerators) {

				// find the target of the keypress event,
				var target = wisej.utils.Widget.findWisejComponent(e.getTarget());
				if (!target)
					return;

				// process only accelerator keys from child widgets.
				if (this !== target
					&& this instanceof qx.ui.core.Widget
					&& !qx.ui.core.Widget.contains(this, target)) {

					return;
				}

				var id = target.isWisejComponent ? target.getId() : null;

				var code = (e.getModifiers() << 16) | e.getKeyCode();
				if (this.__accelerators[code]) {

					e.stopPropagation();
					this.fireDataEvent("accelerator", { code: code, target: id });

					// prevent default for Ctrl accelerators to prevent the browser's default actions.
					if (e.isCtrlPressed())
						e.preventDefault();
				}
				else {
					var key = e.getKeyIdentifier();
					if (this.__accelerators[key]) {

						e.stopPropagation();
						this.fireDataEvent("accelerator", { code: code, target: id });

						// prevent default for browser keys or we get the search box on F3
						// and the tools on F12, etc...
						if (key.length > 1 && key[0] === "F")
							e.preventDefault();
					}
				}
			}
		}
	},

	/**
	 * destruct
	 */
	destruct: function () {

		if (wisej.web.DesignMode)
			return;

		// unregister the accelerator listener.
		wisej.web.manager.Accelerators.getInstance().unregister(null, this.__onAccelerator, this);
	},

});
